/******/var ripple=
/******/(function(modules) {
/******/	var installedModules = {};
/******/	function require(moduleId) {
/******/		if(typeof moduleId !== "number") throw new Error("Cannot find module '"+moduleId+"'");
/******/		if(installedModules[moduleId])
/******/			return installedModules[moduleId].exports;
/******/		var module = installedModules[moduleId] = {
/******/			exports: {},
/******/			id: moduleId,
/******/			loaded: false
/******/		};
/******/		modules[moduleId](module, module.exports, require);
/******/		module.loaded = true;
/******/		return module.exports;
/******/	}
/******/	require.e = function(chunkId, callback) {
/******/		callback(require);
/******/	};
/******/	require.modules = modules;
/******/	require.cache = installedModules;
/******/	return require(0);
/******/})
/******/({c:"",
/******/0: function(module, exports, require) {

eval("exports.Remote = require(7).Remote;\r\nexports.Amount = require(2).Amount;\r\nexports.UInt160 = require(2).UInt160;\r\n\n\n// WEBPACK FOOTER //\n// module.id = 0\n// module.realId = 0\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/index.js");

/******/},
/******/
/******/1: function(module, exports, require) {

eval("var console = (function() { return this[\"console\"] || (this[\"window\"] && this[\"window\"].console) || {} }());\r\nmodule.exports = console;\r\nfor(var name in {log:1, info:1, error:1, warn:1, dir:1, trace:1, assert:1})\r\n\tif(!console[name])\r\n\t\tconsole[name] = function() {};\r\nvar times = {};\r\nif(!console.time)\r\nconsole.time = function(label) {\r\n\ttimes[label] = Date.now();\r\n};\r\nif(!console.timeEnd)\r\nconsole.timeEnd = function() {\r\n\tvar duration = Date.now() - times[label];\r\n\tconsole.log('%s: %dms', label, duration);\r\n};\n\n// WEBPACK FOOTER //\n// module.id = 6\n// module.realId = 1\n// module.chunks = main\n//@ sourceURL=webpack-module:///(webpack)/buildin/__webpack_console.js");

/******/},
/******/
/******/2: function(module, exports, require) {

eval("// Represent Ripple amounts and currencies.\r\n// - Numbers in hex are big-endian.\r\n\r\nvar sjcl    = require(3);\r\nvar bn\t    = require(3).bn;\r\nvar utils   = require(4);\r\nvar jsbn    = require(6);\r\n\r\nvar BigInteger\t= jsbn.BigInteger;\r\nvar nbi\t\t= jsbn.nbi;\r\n\r\nvar alphabets\t= {\r\n  'ripple' : \"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\",\r\n  'bitcoin' : \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\r\n};\r\n\r\nvar consts = exports.consts = {\r\n  'address_xns'\t          : \"rrrrrrrrrrrrrrrrrrrrrhoLvTp\",\r\n  'address_one'\t          : \"rrrrrrrrrrrrrrrrrrrrBZbvji\",\r\n  'currency_xns'          : 0,\r\n  'currency_one'          : 1,\r\n  'uint160_xns'\t          : utils.hexToString(\"0000000000000000000000000000000000000000\"),\r\n  'uint160_one'\t          : utils.hexToString(\"0000000000000000000000000000000000000001\"),\r\n  'hex_xns'\t          : \"0000000000000000000000000000000000000000\",\r\n  'hex_one'\t          : \"0000000000000000000000000000000000000001\",\r\n  'xns_precision'         : 6,\r\n\r\n  // BigInteger values prefixed with bi_.\r\n  'bi_10'\t          : new BigInteger('10'),\r\n  'bi_1e14'               : new BigInteger('100000000000000'),\r\n  'bi_1e16'               : new BigInteger('10000000000000000'),\r\n  'bi_man_max_value'      : new BigInteger('9999999999999999'),\r\n  'bi_man_min_value'      : new BigInteger('1000000000000000'),\r\n  'bi_xns_max'\t          : new BigInteger(\"9000000000000000000\"),\t  // Json wire limit.\r\n  'bi_xns_min'\t          : new BigInteger(\"-9000000000000000000\"),\t  // Json wire limit.\r\n  'bi_xns_unit'\t          : new BigInteger('1000000'),\r\n\r\n  'cMinOffset'            : -96,\r\n  'cMaxOffset'            : 80,\r\n\r\n  'VER_NONE'              : 1,\r\n  'VER_NODE_PUBLIC'       : 28,\r\n  'VER_NODE_PRIVATE'      : 32,\r\n  'VER_ACCOUNT_ID'        : 0,\r\n  'VER_ACCOUNT_PUBLIC'    : 35,\r\n  'VER_ACCOUNT_PRIVATE'   : 34,\r\n  'VER_FAMILY_GENERATOR'  : 41,\r\n  'VER_FAMILY_SEED'       : 33,\r\n};\r\n\r\n// --> input: big-endian array of bytes.\r\n// <-- string at least as long as input.\r\nvar encode_base = function (input, alphabet) {\r\n  var alphabet\t= alphabets[alphabet || 'ripple'];\r\n  var bi_base\t= new BigInteger(String(alphabet.length));\r\n  var bi_q\t= nbi();\r\n  var bi_r\t= nbi();\r\n  var bi_value\t= new BigInteger(input);\r\n  var buffer\t= [];\r\n\r\n  while (bi_value.compareTo(BigInteger.ZERO) > 0)\r\n  {\r\n    bi_value.divRemTo(bi_base, bi_q, bi_r);\r\n    bi_q.copyTo(bi_value);\r\n\r\n    buffer.push(alphabet[bi_r.intValue()]);\r\n  }\r\n\r\n  var i;\r\n\r\n  for (i = 0; i != input.length && !input[i]; i += 1) {\r\n    buffer.push(alphabet[0]);\r\n  }\r\n\r\n  return buffer.reverse().join(\"\");\r\n};\r\n\r\n// --> input: String\r\n// <-- array of bytes or undefined.\r\nvar decode_base = function (input, alphabet) {\r\n  var alphabet\t= alphabets[alphabet || 'ripple'];\r\n  var bi_base\t= new BigInteger(String(alphabet.length));\r\n  var bi_value\t= nbi();\r\n  var i;\r\n\r\n  for (i = 0; i != input.length && input[i] === alphabet[0]; i += 1)\r\n    ;\r\n\r\n  for (; i != input.length; i += 1) {\r\n    var\tv = alphabet.indexOf(input[i]);\r\n\r\n    if (v < 0)\r\n      return undefined;\r\n\r\n    var r = nbi();\r\n\r\n    r.fromInt(v);\r\n\r\n    bi_value  = bi_value.multiply(bi_base).add(r);\r\n  }\r\n\r\n  // toByteArray:\r\n  // - Returns leading zeros!\r\n  // - Returns signed bytes!\r\n  var bytes =  bi_value.toByteArray().map(function (b) { return b ? b < 0 ? 256+b : b : 0});\r\n  var extra = 0;\r\n\r\n  while (extra != bytes.length && !bytes[extra])\r\n    extra += 1;\r\n\r\n  if (extra)\r\n    bytes = bytes.slice(extra);\r\n\r\n  var zeros = 0;\r\n\r\n  while (zeros !== input.length && input[zeros] === alphabet[0])\r\n    zeros += 1;\r\n\r\n  return [].concat(utils.arraySet(zeros, 0), bytes);\r\n};\r\n\r\nvar sha256  = function (bytes) {\r\n  return sjcl.codec.bytes.fromBits(sjcl.hash.sha256.hash(sjcl.codec.bytes.toBits(bytes)));\r\n};\r\n\r\nvar sha256hash = function (bytes) {\r\n  return sha256(sha256(bytes));\r\n};\r\n\r\n// --> input: Array\r\n// <-- String\r\nvar encode_base_check = function (version, input, alphabet) {\r\n  var buffer  = [].concat(version, input);\r\n  var check   = sha256(sha256(buffer)).slice(0, 4);\r\n\r\n  return encode_base([].concat(buffer, check), alphabet);\r\n}\r\n\r\n// --> input : String\r\n// <-- NaN || BigInteger\r\nvar decode_base_check = function (version, input, alphabet) {\r\n  var buffer = decode_base(input, alphabet);\r\n\r\n  if (!buffer || buffer[0] !== version || buffer.length < 5)\r\n    return NaN;\r\n\r\n  var computed\t= sha256hash(buffer.slice(0, -4)).slice(0, 4);\r\n  var checksum\t= buffer.slice(-4);\r\n  var i;\r\n\r\n  for (i = 0; i != 4; i += 1)\r\n    if (computed[i] !== checksum[i])\r\n      return NaN;\r\n\r\n  return new BigInteger(buffer.slice(1, -4));\r\n}\r\n\r\n//\r\n// Seed support\r\n//\r\n\r\nvar Seed = function () {\r\n  // Internal form: NaN or BigInteger\r\n  this._value  = NaN;\r\n};\r\n\r\nSeed.json_rewrite = function (j) {\r\n  return Seed.from_json(j).to_json();\r\n};\r\n\r\n// Return a new Seed from j.\r\nSeed.from_json = function (j) {\r\n  return 'string' === typeof j\r\n      ? (new Seed()).parse_json(j)\r\n      : j.clone();\r\n};\r\n\r\nSeed.is_valid = function (j) {\r\n  return Seed.from_json(j).is_valid();\r\n};\r\n\r\nSeed.prototype.clone = function () {\r\n  return this.copyTo(new Seed());\r\n};\r\n\r\n// Returns copy.\r\nSeed.prototype.copyTo = function (d) {\r\n  d._value = this._value;\r\n\r\n  return d;\r\n};\r\n\r\nSeed.prototype.equals = function (d) {\r\n  return this._value instanceof BigInteger && d._value instanceof BigInteger && this._value.equals(d._value);\r\n};\r\n\r\nSeed.prototype.is_valid = function () {\r\n  return this._value instanceof BigInteger;\r\n};\r\n\r\n// value = NaN on error.\r\n// One day this will support rfc1751 too.\r\nSeed.prototype.parse_json = function (j) {\r\n  if ('string' !== typeof j) {\r\n    this._value  = NaN;\r\n  }\r\n  else if (j[0] === \"s\") {\r\n    this._value  = decode_base_check(consts.VER_FAMILY_SEED, j);\r\n  }\r\n  else if (16 === j.length) {\r\n    this._value  = new BigInteger(utils.stringToArray(j), 128);\r\n  }\r\n  else {\r\n    this._value  = NaN;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Convert from internal form.\r\nSeed.prototype.to_json = function () {\r\n  if (!(this._value instanceof BigInteger))\r\n    return NaN;\r\n\r\n  var bytes   = this._value.toByteArray().map(function (b) { return b ? b < 0 ? 256+b : b : 0});\r\n  var target  = 20;\r\n\r\n  // XXX Make sure only trim off leading zeros.\r\n  var array = bytes.length < target\r\n\t\t? bytes.length\r\n\t\t  ? [].concat(utils.arraySet(target - bytes.length, 0), bytes)\r\n\t\t  : utils.arraySet(target, 0)\r\n\t\t: bytes.slice(target - bytes.length);\r\n  var output = encode_base_check(consts.VER_FAMILY_SEED, array);\r\n\r\n  return output;\r\n};\r\n\r\n//\r\n// UInt160 support\r\n//\r\n\r\nvar UInt160 = function () {\r\n  // Internal form: NaN or BigInteger\r\n  this._value  = NaN;\r\n};\r\n\r\nUInt160.json_rewrite = function (j) {\r\n  return UInt160.from_json(j).to_json();\r\n};\r\n\r\n// Return a new UInt160 from j.\r\nUInt160.from_json = function (j) {\r\n  return 'string' === typeof j\r\n      ? (new UInt160()).parse_json(j)\r\n      : j.clone();\r\n};\r\n\r\nUInt160.is_valid = function (j) {\r\n  return UInt160.from_json(j).is_valid();\r\n};\r\n\r\nUInt160.prototype.clone = function () {\r\n  return this.copyTo(new UInt160());\r\n};\r\n\r\n// Returns copy.\r\nUInt160.prototype.copyTo = function (d) {\r\n  d._value = this._value;\r\n\r\n  return d;\r\n};\r\n\r\nUInt160.prototype.equals = function (d) {\r\n  return this._value instanceof BigInteger && d._value instanceof BigInteger && this._value.equals(d._value);\r\n};\r\n\r\nUInt160.prototype.is_valid = function () {\r\n  return this._value instanceof BigInteger;\r\n};\r\n\r\n// value = NaN on error.\r\nUInt160.prototype.parse_json = function (j) {\r\n  // Canonicalize and validate\r\n  if (exports.config.accounts && j in exports.config.accounts)\r\n    j = exports.config.accounts[j].account;\r\n\r\n  switch (j) {\r\n    case undefined:\r\n    case \"0\":\r\n    case consts.address_xns:\r\n    case consts.uint160_xns:\r\n    case consts.hex_xns:\r\n      this._value  = nbi();\r\n      break;\r\n\r\n    case \"1\":\r\n    case consts.address_one:\r\n    case consts.uint160_one:\r\n    case consts.hex_one:\r\n      this._value  = new BigInteger([1]);\r\n\r\n      break;\r\n\r\n    default:\r\n      if ('string' !== typeof j) {\r\n\tthis._value  = NaN;\r\n      }\r\n      else if (j[0] === \"r\") {\r\n\tthis._value  = decode_base_check(consts.VER_ACCOUNT_ID, j);\r\n      }\r\n      else if (20 === j.length) {\r\n\tthis._value  = new BigInteger(utils.stringToArray(j), 256);\r\n      }\r\n      else if (40 === j.length) {\r\n\t// XXX Check char set!\r\n\tthis._value  = new BigInteger(j, 16);\r\n      }\r\n      else {\r\n\tthis._value  = NaN;\r\n      }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Convert from internal form.\r\n// XXX Json form should allow 0 and 1, C++ doesn't currently allow it.\r\nUInt160.prototype.to_json = function () {\r\n  if (!(this._value instanceof BigInteger))\r\n    return NaN;\r\n\r\n  var bytes   = this._value.toByteArray().map(function (b) { return b ? b < 0 ? 256+b : b : 0});\r\n  var target  = 20;\r\n\r\n  // XXX Make sure only trim off leading zeros.\r\n  var array = bytes.length < target\r\n\t\t? bytes.length\r\n\t\t  ? [].concat(utils.arraySet(target - bytes.length, 0), bytes)\r\n\t\t  : utils.arraySet(target, 0)\r\n\t\t: bytes.slice(target - bytes.length);\r\n  var output = encode_base_check(consts.VER_ACCOUNT_ID, array);\r\n\r\n  return output;\r\n};\r\n\r\n//\r\n// Currency support\r\n//\r\n\r\n// XXX Internal form should be UInt160.\r\nvar Currency = function () {\r\n  // Internal form: 0 = XRP. 3 letter-code.\r\n  // XXX Internal should be 0 or hex with three letter annotation when valid.\r\n\r\n  // Json form:\r\n  //  '', 'XRP', '0': 0\r\n  //  3-letter code: ...\r\n  // XXX Should support hex, C++ doesn't currently allow it.\r\n\r\n  this._value  = NaN;\r\n}\r\n\r\n// Given \"USD\" return the json.\r\nCurrency.json_rewrite = function (j) {\r\n  return Currency.from_json(j).to_json();\r\n};\r\n\r\nCurrency.from_json = function (j) {\r\n  return 'string' === typeof j\r\n      ? (new Currency()).parse_json(j)\r\n      : j.clone();\r\n};\r\n\r\nCurrency.is_valid = function (j) {\r\n  return currency.from_json(j).is_valid();\r\n};\r\n\r\nCurrency.prototype.clone = function() {\r\n  return this.copyTo(new Currency());\r\n};\r\n\r\n// Returns copy.\r\nCurrency.prototype.copyTo = function (d) {\r\n  d._value = this._value;\r\n\r\n  return d;\r\n};\r\n\r\nCurrency.prototype.equals = function (d) {\r\n  return ('string' !== typeof this._value && isNaN(this._value))\r\n    || ('string' !== typeof d._value && isNaN(d._value)) ? false : this._value === d._value;\r\n};\r\n\r\n// this._value = NaN on error.\r\nCurrency.prototype.parse_json = function (j) {\r\n  if (\"\" === j || \"0\" === j || \"XRP\" === j) {\r\n    this._value\t= 0;\r\n  }\r\n  else if ('string' != typeof j || 3 !== j.length) {\r\n    this._value\t= NaN;\r\n  }\r\n  else {\r\n    this._value\t= j;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nCurrency.prototype.is_native = function () {\r\n  return !isNaN(this._value) && !this._value;\r\n};\r\n\r\nCurrency.prototype.is_valid = function () {\r\n  return !isNaN(this._value);\r\n};\r\n\r\nCurrency.prototype.to_json = function () {\r\n  return this._value ? this._value : \"XRP\";\r\n};\r\n\r\nCurrency.prototype.to_human = function () {\r\n  return this._value ? this._value : \"XRP\";\r\n};\r\n\r\n//\r\n// Amount class in the style of Java's BigInteger class\r\n// http://docs.oracle.com/javase/1.3/docs/api/java/math/BigInteger.html\r\n//\r\n\r\nvar Amount = function () {\r\n  // Json format:\r\n  //  integer : XRP\r\n  //  { 'value' : ..., 'currency' : ..., 'issuer' : ...}\r\n\r\n  this._value\t    = new BigInteger();\t// NaN for bad value. Always positive for non-XRP.\r\n  this._offset\t    = undefined;\t// For non-XRP.\r\n  this._is_native   = true;\t\t// Default to XRP. Only valid if value is not NaN.\r\n  this._is_negative = undefined;\t// For non-XRP. Undefined for XRP.\r\n\r\n  this._currency    = new Currency();\r\n  this._issuer\t    = new UInt160();\r\n};\r\n\r\n// Given \"100/USD/mtgox\" return the a string with mtgox remapped.\r\nAmount.text_full_rewrite = function (j) {\r\n  return Amount.from_json(j).to_text_full();\r\n}\r\n\r\n// Given \"100/USD/mtgox\" return the json.\r\nAmount.json_rewrite = function (j) {\r\n  return Amount.from_json(j).to_json();\r\n};\r\n\r\nAmount.from_json = function (j) {\r\n  return (new Amount()).parse_json(j);\r\n};\r\n\r\nAmount.from_human = function (j) {\r\n  return (new Amount()).parse_human(j);\r\n};\r\n\r\nAmount.is_valid = function (j) {\r\n  return Amount.from_json(j).is_valid();\r\n};\r\n\r\nAmount.is_valid_full = function (j) {\r\n  return Amount.from_json(j).is_valid_full();\r\n};\r\n\r\nAmount.NaN = function () {\r\n  var result = new Amount();\r\n  \r\n  result._value = NaN;\r\n  \r\n  return result;\r\n};\r\n\r\n// Returns a new value which is the absolute value of this.\r\nAmount.prototype.abs = function () {\r\n  return this.clone(this.is_negative());\r\n};\r\n\r\n// Result in terms of this' currency and issuer.\r\nAmount.prototype.add = function (v) {\r\n  var result;\r\n\r\n  if (!this.is_comparable(v)) {\r\n    result              = Amount.NaN();\r\n  }\r\n  else if (this._is_native) {\r\n    result              = new Amount();\r\n    result._value       = this._value.add(v._value);\r\n  }\r\n  else {\r\n    var v1  = this._is_negative ? this._value.negate() : this._value;\r\n    var o1  = this._offset;\r\n    var v2  = v._is_negative ? v._value.negate() : v._value;\r\n    var o2  = v._offset;\r\n\r\n    while (o1 < o2) {\r\n      v1  = v1.divide(consts.bi_10);\r\n      o1  += 1;\r\n    }\r\n\r\n    while (o2 < o1) {\r\n      v2  = v2.divide(consts.bi_10);\r\n      o2  += 1;\r\n    }\r\n\r\n    result              = new Amount();\r\n    result._offset      = o1;\r\n    result._value       = v1.add(v2);\r\n    result._is_negative = result._value.compareTo(BigInteger.ZERO) < 0;\r\n    \r\n    if (result._is_negative) {\r\n      result._value       = result._value.negate();\r\n      result._is_negative = false;\r\n    }\r\n\r\n    result._currency    = this._currency.clone();\r\n    result._issuer      = this._issuer.clone();\r\n\r\n    result.canonicalize();\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nAmount.prototype.canonicalize = function () {\r\n  if (!(this._value instanceof BigInteger))\r\n  {\r\n    // NaN.\r\n    // nothing\r\n  }\r\n  else if (this._is_native) {\r\n    // Native.\r\n    // XXX Make sure not bigger than supported. Throw if so.\r\n  }\r\n  else if (this.is_zero()) {\r\n    this._offset      = -100;\r\n    this._is_negative = false;\r\n  }\r\n  else\r\n  {\r\n    while (this._value.compareTo(consts.bi_man_min_value) < 0) {\r\n      this._value  = this._value.multiply(consts.bi_10);\r\n      this._offset -= 1;\r\n    }\r\n\r\n    while (this._value.compareTo(consts.bi_man_max_value) > 0) {\r\n      this._value  = this._value.divide(consts.bi_10);\r\n      this._offset += 1;\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nAmount.prototype.clone = function (negate) {\r\n  return this.copyTo(new Amount(), negate);\r\n};\r\n\r\nAmount.prototype.compareTo = function (v) {\r\n  var result;\r\n\r\n  if (!this.is_comparable(v)) {\r\n    result  = Amount.NaN();\r\n  }\r\n  else if (this._is_native) {\r\n    result  = this._value.compareTo(v._value);\r\n\r\n    if (result > 1)\r\n      result  = 1;\r\n    else if (result < -1)\r\n      result  = -1;\r\n  }\r\n  else if (this._is_negative != v._is_negative) {\r\n    result  = this._is_negative ? -1 : 1;\r\n  }\r\n  else if (this._value.equals(BigInteger.ZERO)) {\r\n    result  = v._is_negative\r\n                ? 1\r\n                : v._value.equals(BigInteger.ZERO)\r\n                  ? 0\r\n                  : 1;\r\n  }\r\n  else if (v._value.equals(BigInteger.ZERO)) {\r\n    result  = 1;\r\n  }\r\n  else if (this._offset > v._offset) {\r\n    result  = this._is_negative ? -1 : 1;\r\n  }\r\n  else if (this._offset < v._offset) {\r\n    result  = this._is_negative ? 1 : -1;\r\n  }\r\n  else {\r\n    result  = this._value.compareTo(v._value);\r\n\r\n    if (result > 1)\r\n      result  = 1;\r\n    else if (result < -1)\r\n      result  = -1;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// Returns copy.\r\nAmount.prototype.copyTo = function (d, negate) {\r\n  if ('object' === typeof this._value)\r\n  {\r\n    if (this._is_native && negate)\r\n      this._value.negate().copyTo(d._value);\r\n    else\r\n      this._value.copyTo(d._value);\r\n  }\r\n  else\r\n  {\r\n    d._value   = this._value;\r\n  }\r\n\r\n  d._offset\t  = this._offset;\r\n  d._is_native\t  = this._is_native;\r\n  d._is_negative  = this._is_native\r\n\t\t      ? undefined\t        // Native sign in BigInteger.\r\n\t\t      : negate\r\n\t\t\t? !this._is_negative    // Negating.\r\n\t\t\t: this._is_negative;    // Just copying.\r\n\r\n  this._currency.copyTo(d._currency);\r\n  this._issuer.copyTo(d._issuer);\r\n\r\n  return d;\r\n};\r\n\r\nAmount.prototype.currency = function () {\r\n  return this._currency;\r\n};\r\n\r\n// Check BigInteger NaN\r\n// Checks currency, does not check issuer.\r\nAmount.prototype.equals = function (d) {\r\n  return 'string' === typeof (d)\r\n    ? this.equals(Amount.from_json(d))\r\n    : this === d\r\n      || (d instanceof Amount\r\n\t&& this._is_native === d._is_native\r\n\t&& (this._is_native\r\n\t    ? this._value.equals(d._value)\r\n\t    : this._currency.equals(d._currency)\r\n\t      ? this._is_negative === d._is_negative\r\n\t\t? this._value.equals(d._value)\r\n\t\t: this._value.equals(BigInteger.ZERO) && d._value.equals(BigInteger.ZERO)\r\n\t      : false));\r\n};\r\n\r\n// Result in terms of this' currency and issuer.\r\nAmount.prototype.divide = function (d) {\r\n  var result;\r\n\r\n  if (!this.is_comparable(d)) {\r\n    // XXX We might want to allow mixed division. In that case convert d to same terms as this.\r\n    result              = Amount.NaN();\r\n  }\r\n  else if (d.is_zero()) {\r\n    throw \"divide by zero\";\r\n  }\r\n  else if (this.is_zero()) {\r\n    result  = this;\r\n  }\r\n  else if (this._is_native) {\r\n    var vn  = this._value;\r\n    var on  = this._offset;\r\n    var vd  = d._value;\r\n    var od  = d._offset;\r\n\r\n    while (vn.compareTo(consts.bi_man_min_value) < 0) {\r\n      vn  = vn.multiply(consts.bi_10);\r\n      on  -= 1;\r\n    }\r\n\r\n    while (dn.compareTo(consts.bi_man_min_value) < 0) {\r\n      vd  = vn.multiply(consts.bi_10);\r\n      od  -= 1;\r\n    }\r\n\r\n    result              = new Amount();\r\n    result._value       = vn.multiply(consts.bi_1e16).divide(vd);\r\n\r\n    if (this._is_negative != d._is_negative)\r\n      result._value = result._value.negate();\r\n\r\n    // XXX Check range?\r\n  }\r\n  else {\r\n    var vn  = this._value.multiply(consts.bi_10).add(3);\r\n    var on  = this._offset - 1;\r\n    var vd  = d._value.multiply(consts.bi_10).add(3);\r\n    var od  = d._offset - 1;\r\n\r\n    result              = new Amount();\r\n    result._offset      = on+od-16;\r\n    result._value       = vn.multiply(consts.bi_1e16).divide(vd);\r\n    result._is_negative = this._is_negative != d._is_negative;\r\n    result._currency    = this._currency.clone();\r\n    result._issuer      = this._issuer.clone();\r\n    \r\n    if (result._offset > cMaxOffset || result._offset < cMaxOffset)\r\n      throw \"division result out of range.\";\r\n\r\n    // XXX Check value is in legal range here or have canonicalize do it?\r\n\r\n    result.canonicalize();\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// True if Amounts are valid and both native or non-native.\r\nAmount.prototype.is_comparable = function (v) {\r\n  return this._value instanceof BigInteger\r\n    && v._value instanceof BigInteger\r\n    && this._is_native === v.is_native;\r\n};\r\n\r\nAmount.prototype.is_native = function () {\r\n  return this._is_native;\r\n};\r\n\r\nAmount.prototype.is_negative = function () {\r\n  return this._value instanceof BigInteger\r\n          ? this.is_native\r\n            ? this._value.compareTo(BigInteger.ZERO) < 0\r\n            : this._is_negative\r\n          : false;                          // NaN is not negative\r\n};\r\n\r\n// Only checks the value. Not the currency and issuer.\r\nAmount.prototype.is_valid = function () {\r\n  return this._value instanceof BigInteger;\r\n};\r\n\r\nAmount.prototype.is_valid_full = function () {\r\n  return this.is_valid() && this._currency.is_valid() && this._issuer.is_valid();\r\n};\r\n\r\nAmount.prototype.is_zero = function () {\r\n  return this._value instanceof BigInteger\r\n          ? this._value.equals(BigInteger.ZERO)\r\n          : false;\r\n};\r\n\r\nAmount.prototype.issuer = function () {\r\n  return this._issuer;\r\n};\r\n\r\n// Result in terms of this' currency and issuer.\r\nAmount.prototype.multiply = function (v) {\r\n  var result;\r\n\r\n  if (!this.is_comparable(v)) {\r\n    result              = Amount.NaN();\r\n  }\r\n  else if (this._is_native) {\r\n    result              = new Amount();\r\n    result._value       = this._value.multiply(v._value);\r\n  }\r\n  else {\r\n    var v1  = this._value.multiply(consts.bi_10).add(3);\r\n    var o1  = this._offset - 1;\r\n    var v2  = v._value.multiply(consts.bi_10).add(3);\r\n    var o2  = v._offset - 1;\r\n\r\n    // XXX Do we really need to do the offer +14 and divide? Can't canonicalize adjust.\r\n    result              = new Amount();\r\n    result._offset      = o1+o2+14;\r\n    result._value       = v1.multiply(v2).divide(consts.bi_1e14);\r\n    result._is_negative = this._is_negative != v._is_negative;\r\n    result._currency    = this._currency.clone();\r\n    result._issuer      = this._issuer.clone();\r\n    \r\n    // XXX Check value is in legal range here or have canonicalize do it?\r\n\r\n    result.canonicalize();\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// Return a new value.\r\nAmount.prototype.negate = function () {\r\n  return this.clone('NEGATE');\r\n};\r\n\r\n/**\r\n * Tries to correctly interpret an amount as entered by a user.\r\n *\r\n * Examples:\r\n *\r\n *   XRP 250     => 250000000/XRP\r\n *   25.2 XRP    => 25200000/XRP\r\n *   USD 100.40  => 100.4/USD/?\r\n *   100         => 100000000/XRP\r\n */\r\nAmount.prototype.parse_human = function (j) {\r\n  // Cast to string\r\n  j = \"\"+j;\r\n\r\n  // Parse\r\n  var m = j.match(/^\\s*([a-z]{3})?\\s*(-)?(\\d+)(?:\\.(\\d*))?\\s*([a-z]{3})?\\s*$/i);\r\n\r\n  if (m) {\r\n    var currency   = m[1] || m[5] || \"XRP\",\r\n        integer    = m[3] || \"0\",\r\n        fraction   = m[4] || \"\",\r\n        precision  = null;\r\n\r\n    currency = currency.toUpperCase();\r\n\r\n    this._value = new BigInteger(integer);\r\n    this.set_currency(currency);\r\n\r\n    // XRP have exactly six digits of precision\r\n    if (currency === 'XRP') {\r\n      fraction = fraction.slice(0, 6);\r\n      while (fraction.length < 6) {\r\n        fraction += \"0\";\r\n      }\r\n      this._is_native   = true;\r\n      this._value       = this._value.multiply(consts.bi_xns_unit).add(new BigInteger(fraction));\r\n    }\r\n    // Other currencies have arbitrary precision\r\n    else {\r\n      while (fraction[fraction.length - 1] === \"0\") {\r\n        fraction = fraction.slice(0, fraction.length - 1);\r\n      }\r\n\r\n      precision = fraction.length;\r\n\r\n      this._is_native   = false;\r\n      var multiplier    = consts.bi_10.clone().pow(precision);\r\n      this._value      \t= this._value.multiply(multiplier).add(new BigInteger(fraction));\r\n      this._offset     \t= -precision;\r\n\r\n      this.canonicalize();\r\n    }\r\n\r\n    this._is_negative = !!m[2];\r\n  } else {\r\n    this._value\t      = NaN;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nAmount.prototype.parse_issuer = function (issuer) {\r\n  this._issuer.parse_json(issuer);\r\n\r\n  return this;\r\n};\r\n\r\n// <-> j\r\nAmount.prototype.parse_json = function (j) {\r\n  if ('string' === typeof j) {\r\n    // .../.../... notation is not a wire format.  But allowed for easier testing.\r\n    var\tm = j.match(/^(.+)\\/(...)\\/(.+)$/);\r\n\r\n    if (m) {\r\n      this._currency  = Currency.from_json(m[2]);\r\n      this._issuer    = UInt160.from_json(m[3]);\r\n      this.parse_value(m[1]);\r\n    }\r\n    else {\r\n      this.parse_native(j);\r\n      this._currency  = new Currency();\r\n      this._issuer    = new UInt160();\r\n    }\r\n  }\r\n  else if ('object' === typeof j && j instanceof Amount) {\r\n    j.copyTo(this);\r\n  }\r\n  else if ('object' === typeof j && 'value' in j) {\r\n    // Parse the passed value to sanitize and copy it.\r\n\r\n    this._currency.parse_json(j.currency);     // Never XRP.\r\n    if (\"string\" === typeof j.issuer) this._issuer.parse_json(j.issuer);\r\n    this.parse_value(j.value);\r\n  }\r\n  else {\r\n    this._value\t    = NaN;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Parse a XRP value from untrusted input.\r\n// - integer = raw units\r\n// - float = with precision 6\r\n// XXX Improvements: disallow leading zeros.\r\nAmount.prototype.parse_native = function (j) {\r\n  var m;\r\n\r\n  if ('string' === typeof j)\r\n    m = j.match(/^(-?)(\\d+)(\\.\\d{0,6})?$/);\r\n\r\n  if (m) {\r\n    if (undefined === m[3]) {\r\n      // Integer notation\r\n\r\n      this._value\t  = new BigInteger(m[2]);\r\n    }\r\n    else {\r\n      // Float notation : values multiplied by 1,000,000.\r\n\r\n      var   int_part\t  = (new BigInteger(m[2])).multiply(consts.bi_xns_unit);\r\n      var   fraction_part = (new BigInteger(m[3])).multiply(new BigInteger(String(Math.pow(10, 1+consts.xns_precision-m[3].length))));\r\n\r\n      this._value\t  = int_part.add(fraction_part);\r\n    }\r\n\r\n    if (m[1])\r\n      this._value  = this._value.negate();\r\n\r\n    this._is_native   = true;\r\n    this._offset      = undefined;\r\n    this._is_negative = undefined;\r\n\r\n    if (this._value.compareTo(consts.bi_xns_max) > 0 || this._value.compareTo(consts.bi_xns_min) < 0)\r\n    {\r\n      this._value\t  = NaN;\r\n    }\r\n  }\r\n  else {\r\n    this._value\t      = NaN;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Parse a non-native value for the json wire format.\r\n// Requires _currency to be set!\r\nAmount.prototype.parse_value = function (j) {\r\n  this._is_native    = false;\r\n\r\n  if ('number' === typeof j) {\r\n    this._is_negative  = j < 0;\r\n      if (this._is_negative) j = -j;\r\n    this._value\t      = new BigInteger(j);\r\n    this._offset      = 0;\r\n\r\n    this.canonicalize();\r\n  }\r\n  else if ('string' === typeof j) {\r\n    var\ti = j.match(/^(-?)(\\d+)$/);\r\n    var\td = !i && j.match(/^(-?)(\\d+)\\.(\\d*)$/);\r\n    var\te = !e && j.match(/^(-?)(\\d+)e(\\d+)$/);\r\n\r\n    if (e) {\r\n      // e notation\r\n\r\n      this._value\t= new BigInteger(e[2]);\r\n      this._offset \t= parseInt(e[3]);\r\n      this._is_negative\t= !!e[1];\r\n\r\n      this.canonicalize();\r\n    }\r\n    else if (d) {\r\n      // float notation\r\n\r\n      var integer\t= new BigInteger(d[2]);\r\n      var fraction    \t= new BigInteger(d[3]);\r\n      var precision\t= d[3].length;\r\n\r\n      this._value      \t= integer.multiply(consts.bi_10.clone().pow(precision)).add(fraction);\r\n      this._offset     \t= -precision;\r\n      this._is_negative = !!d[1];\r\n\r\n      this.canonicalize();\r\n    }\r\n    else if (i) {\r\n      // integer notation\r\n\r\n      this._value\t= new BigInteger(i[2]);\r\n      this._offset \t= 0;\r\n      this._is_negative  = !!i[1];\r\n\r\n      this.canonicalize();\r\n    }\r\n    else {\r\n      this._value\t= NaN;\r\n    }\r\n  }\r\n  else if (j instanceof BigInteger) {\r\n    this._value\t      = j.clone();\r\n  }\r\n  else {\r\n    this._value\t      = NaN;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nAmount.prototype.set_currency = function (c) {\r\n  if ('string' === typeof c) {\r\n    this._currency.parse_json(c);  \r\n  }\r\n  else\r\n  {\r\n    c.copyTo(this._currency);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nAmount.prototype.set_issuer = function (issuer) {\r\n  if (issuer instanceof UInt160) {\r\n    issuer.copyTo(this._issuer);\r\n  } else {\r\n    this._issuer.parse_json(issuer);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Result in terms of this' currency and issuer.\r\nAmount.prototype.subtract = function (v) {\r\n  // Correctness over speed, less code has less bugs, reuse add code.\r\n  return this.add(v.negate());\r\n};\r\n\r\nAmount.prototype.to_number = function (allow_nan) {\r\n  var s = this.to_text(allow_nan);\r\n\r\n  return ('string' === typeof s) ? Number(s) : s;\r\n}\r\n\r\n// Convert only value to JSON wire format.\r\nAmount.prototype.to_text = function (allow_nan) {\r\n  if (!(this._value instanceof BigInteger)) {\r\n    // Never should happen.\r\n    return allow_nan ? NaN : \"0\";\r\n  }\r\n  else if (this._is_native) {\r\n    if (this._value.compareTo(consts.bi_xns_max) > 0 || this._value.compareTo(consts.bi_xns_min) < 0)\r\n    {\r\n      // Never should happen.\r\n      return allow_nan ? NaN : \"0\";\r\n    }\r\n    else\r\n    {\r\n      return this._value.toString();\r\n    }\r\n  }\r\n  else if (this.is_zero())\r\n  {\r\n    return \"0\";\r\n  }\r\n  else if (this._offset < -25 || this._offset > -5)\r\n  {\r\n    // Use e notation.\r\n    // XXX Clamp output.\r\n\r\n    return (this._is_negative ? \"-\" : \"\") + this._value.toString() + \"e\" + this._offset;\r\n  }\r\n  else\r\n  {\r\n    var val = \"000000000000000000000000000\" + this._value.toString() + \"00000000000000000000000\";\r\n    var\tpre = val.substring(0, this._offset + 43);\r\n    var\tpost = val.substring(this._offset + 43);\r\n    var\ts_pre = pre.match(/[1-9].*$/);\t  // Everything but leading zeros.\r\n    var\ts_post = post.match(/[1-9]0*$/);  // Last non-zero plus trailing zeros.\r\n\r\n    return (this._is_negative ? \"-\" : \"\")\r\n      + (s_pre ? s_pre[0] : \"0\")\r\n      + (s_post ? \".\" + post.substring(0, 1+post.length-s_post[0].length) : \"\");\r\n  }\r\n};\r\n\r\n/**\r\n * Format only value in a human-readable format.\r\n *\r\n * @example\r\n *   var pretty = amount.to_human({precision: 2});\r\n *\r\n * @param opts Options for formatter.\r\n * @param opts.precision {Number} Max. number of digits after decimal point.\r\n * @param opts.group_sep {Boolean|String} Whether to show a separator every n\r\n *   digits, if a string, that value will be used as the separator. Default: \",\"\r\n * @param opts.group_width {Number} How many numbers will be grouped together,\r\n *   default: 3.\r\n * @param opts.signed {Boolean|String} Whether negative numbers will have a\r\n *   prefix. If String, that string will be used as the prefix. Default: \"-\"\r\n */\r\nAmount.prototype.to_human = function (opts)\r\n{\r\n  opts = opts || {};\r\n\r\n  // Default options\r\n  if (\"undefined\" === typeof opts.signed) opts.signed = true;\r\n  if (\"undefined\" === typeof opts.group_sep) opts.group_sep = true;\r\n  opts.group_width = opts.group_width || 3;\r\n\r\n  var order = this._is_native ? consts.xns_precision : -this._offset;\r\n  var denominator = consts.bi_10.clone().pow(order);\r\n  var int_part = this._value.divide(denominator).toString(10);\r\n  var fraction_part = this._value.mod(denominator).toString(10);\r\n\r\n  // Add leading zeros to fraction\r\n  while (fraction_part.length < order) {\r\n    fraction_part = \"0\" + fraction_part;\r\n  }\r\n\r\n  int_part = int_part.replace(/^0*/, '');\r\n  fraction_part = fraction_part.replace(/0*$/, '');\r\n\r\n  if (\"number\" === typeof opts.precision) {\r\n    fraction_part = fraction_part.slice(0, opts.precision);\r\n  }\r\n\r\n  if (opts.group_sep) {\r\n    if (\"string\" !== typeof opts.group_sep) {\r\n      opts.group_sep = ',';\r\n    }\r\n    int_part = utils.chunkString(int_part, opts.group_width, true).join(opts.group_sep);\r\n  }\r\n\r\n  var formatted = '';\r\n  if (opts.signed && this._is_negative) {\r\n    if (\"string\" !== typeof opts.signed) {\r\n      opts.signed = '-';\r\n    }\r\n    formatted += opts.signed;\r\n  }\r\n  formatted += int_part.length ? int_part : '0';\r\n  formatted += fraction_part.length ? '.'+fraction_part : '';\r\n\r\n  return formatted;\r\n};\r\n\r\nAmount.prototype.to_json = function () {\r\n  if (this._is_native) {\r\n    return this.to_text();\r\n  }\r\n  else\r\n  {\r\n    var amount_json = {\r\n      'value' : this.to_text(),\r\n      'currency' : this._currency.to_json()\r\n    };\r\n    if (this._issuer.is_valid()) {\r\n      amount_json.issuer = this._issuer.to_json();\r\n    }\r\n    return amount_json;\r\n  }\r\n};\r\n\r\nAmount.prototype.to_text_full = function () {\r\n  return this._value instanceof BigInteger\r\n    ? this._is_native\r\n      ? this.to_text() + \"/XRP\"\r\n      : this.to_text() + \"/\" + this._currency.to_json() + \"/\" + this._issuer.to_json()\r\n    : NaN;\r\n};\r\n\r\n// For debugging.\r\nAmount.prototype.not_equals_why = function (d) {\r\n  return 'string' === typeof (d)\r\n    ? this.not_equals_why(Amount.from_json(d))\r\n    : this === d\r\n      ? false\r\n      : d instanceof Amount\r\n\t  ? this._is_native === d._is_native\r\n\t    ? this._is_native\r\n\t\t? this._value.equals(d._value)\r\n\t\t  ? false\r\n\t\t  : \"XRP value differs.\"\r\n\t\t: this._currency.equals(d._currency)\r\n\t\t  ? this._is_negative === d._is_negative\r\n\t\t    ? this._value.equals(d._value)\r\n\t\t      ? false\r\n\t\t      : this._value.equals(BigInteger.ZERO) && d._value.equals(BigInteger.ZERO)\r\n\t\t\t? false\r\n\t\t\t: \"Non-XRP value differs.\"\r\n\t\t    : \"Non-XRP sign differs.\"\r\n\t\t  : \"Non-XRP currency differs (\" + JSON.stringify(this._currency) + \"/\" + JSON.stringify(d._currency) + \")\"\r\n\t    : \"Native mismatch\"\r\n\t  : \"Wrong constructor.\"\r\n};\r\n\r\nexports.Amount\t      = Amount;\r\nexports.Currency      = Currency;\r\nexports.Seed          = Seed;\r\nexports.UInt160\t      = UInt160;\r\n\r\nexports.config\t      = {};\r\n\r\n// vim:sw=2:sts=2:ts=8:et\r\n\n\n// WEBPACK FOOTER //\n// module.id = 2\n// module.realId = 2\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/amount.js");

/******/},
/******/
/******/3: function(module, exports, require) {

eval("/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape */\n\n/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */\nvar sjcl = {\n  /** @namespace Symmetric ciphers. */\n  cipher: {},\n\n  /** @namespace Hash functions.  Right now only SHA256 is implemented. */\n  hash: {},\n\n  /** @namespace Key exchange functions.  Right now only SRP is implemented. */\n  keyexchange: {},\n  \n  /** @namespace Block cipher modes of operation. */\n  mode: {},\n\n  /** @namespace Miscellaneous.  HMAC and PBKDF2. */\n  misc: {},\n  \n  /**\n   * @namespace Bit array encoders and decoders.\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /** @namespace Exceptions. */\n  exception: {\n    /** @class Ciphertext is corrupt. */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /** @class Invalid parameter. */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /** @class Bug or missing feature in SJCL. */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /** @class Something isn't ready. */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n\nif(typeof module != 'undefined' && module.exports){\n  module.exports = sjcl;\n}\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n *\n * @class Advanced Encryption Standard (low-level interface)\n */\nsjcl.cipher.aes = function (key) {\n  if (!this._tables[0][0][0]) {\n    this._precompute();\n  }\n  \n  var i, j, tmp,\n    encKey, decKey,\n    sbox = this._tables[0][4], decTable = this._tables[1],\n    keyLen = key.length, rcon = 1;\n  \n  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n    throw new sjcl.exception.invalid(\"invalid aes key size\");\n  }\n  \n  this._key = [encKey = key.slice(0), decKey = []];\n  \n  // schedule encryption keys\n  for (i = keyLen; i < 4 * keyLen + 28; i++) {\n    tmp = encKey[i-1];\n    \n    // apply sbox\n    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {\n      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];\n      \n      // shift rows and add rcon\n      if (i%keyLen === 0) {\n        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;\n        rcon = rcon<<1 ^ (rcon>>7)*283;\n      }\n    }\n    \n    encKey[i] = encKey[i-keyLen] ^ tmp;\n  }\n  \n  // schedule decryption keys\n  for (j = 0; i; j++, i--) {\n    tmp = encKey[j&3 ? i : i - 4];\n    if (i<=4 || j<4) {\n      decKey[j] = tmp;\n    } else {\n      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^\n                  decTable[1][sbox[tmp>>16  & 255]] ^\n                  decTable[2][sbox[tmp>>8   & 255]] ^\n                  decTable[3][sbox[tmp      & 255]];\n    }\n  }\n};\n\nsjcl.cipher.aes.prototype = {\n  // public\n  /* Something like this might appear here eventually\n  name: \"AES\",\n  blockSize: 4,\n  keySizes: [4,6,8],\n  */\n  \n  /**\n   * Encrypt an array of 4 big-endian words.\n   * @param {Array} data The plaintext.\n   * @return {Array} The ciphertext.\n   */\n  encrypt:function (data) { return this._crypt(data,0); },\n  \n  /**\n   * Decrypt an array of 4 big-endian words.\n   * @param {Array} data The ciphertext.\n   * @return {Array} The plaintext.\n   */\n  decrypt:function (data) { return this._crypt(data,1); },\n  \n  /**\n   * The expanded S-box and inverse S-box tables.  These will be computed\n   * on the client so that we don't have to send them down the wire.\n   *\n   * There are two tables, _tables[0] is for encryption and\n   * _tables[1] is for decryption.\n   *\n   * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n   * last (_tables[01][4]) is the S-box itself.\n   *\n   * @private\n   */\n  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],\n\n  /**\n   * Expand the S-box tables.\n   *\n   * @private\n   */\n  _precompute: function () {\n   var encTable = this._tables[0], decTable = this._tables[1],\n       sbox = encTable[4], sboxInv = decTable[4],\n       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;\n\n    // Compute double and third tables\n   for (i = 0; i < 256; i++) {\n     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;\n   }\n   \n   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n     // Compute sbox\n     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;\n     s = s>>8 ^ s&255 ^ 99;\n     sbox[x] = s;\n     sboxInv[s] = x;\n     \n     // Compute MixColumns\n     x8 = d[x4 = d[x2 = d[x]]];\n     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;\n     tEnc = d[s]*0x101 ^ s*0x1010100;\n     \n     for (i = 0; i < 4; i++) {\n       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;\n       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;\n     }\n   }\n   \n   // Compactify.  Considerable speedup on Firefox.\n   for (i = 0; i < 5; i++) {\n     encTable[i] = encTable[i].slice(0);\n     decTable[i] = decTable[i].slice(0);\n   }\n  },\n  \n  /**\n   * Encryption and decryption core.\n   * @param {Array} input Four words to be encrypted or decrypted.\n   * @param dir The direction, 0 for encrypt and 1 for decrypt.\n   * @return {Array} The four encrypted or decrypted words.\n   * @private\n   */\n  _crypt:function (input, dir) {\n    if (input.length !== 4) {\n      throw new sjcl.exception.invalid(\"invalid aes block size\");\n    }\n    \n    var key = this._key[dir],\n        // state variables a,b,c,d are loaded with pre-whitened data\n        a = input[0]           ^ key[0],\n        b = input[dir ? 3 : 1] ^ key[1],\n        c = input[2]           ^ key[2],\n        d = input[dir ? 1 : 3] ^ key[3],\n        a2, b2, c2,\n        \n        nInnerRounds = key.length/4 - 2,\n        i,\n        kIndex = 4,\n        out = [0,0,0,0],\n        table = this._tables[dir],\n        \n        // load up the tables\n        t0    = table[0],\n        t1    = table[1],\n        t2    = table[2],\n        t3    = table[3],\n        sbox  = table[4];\n \n    // Inner rounds.  Cribbed from OpenSSL.\n    for (i = 0; i < nInnerRounds; i++) {\n      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];\n      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a=a2; b=b2; c=c2;\n    }\n        \n    // Last round.\n    for (i = 0; i < 4; i++) {\n      out[dir ? 3&-i : i] =\n        sbox[a>>>24      ]<<24 ^ \n        sbox[b>>16  & 255]<<16 ^\n        sbox[c>>8   & 255]<<8  ^\n        sbox[d      & 255]     ^\n        key[kIndex++];\n      a2=a; a=b; b=c; c=d; d=a2;\n    }\n    \n    return out;\n  }\n};\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Arrays of bits, encoded as arrays of Numbers.\n *\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} length The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var out, i, last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n \n/** @namespace UTF-8 strings */\nsjcl.codec.utf8String = {\n  /** Convert from a bitArray to a UTF-8 string. */\n  fromBits: function (arr) {\n    var out = \"\", bl = sjcl.bitArray.bitLength(arr), i, tmp;\n    for (i=0; i<bl/8; i++) {\n      if ((i&3) === 0) {\n        tmp = arr[i/4];\n      }\n      out += String.fromCharCode(tmp >>> 24);\n      tmp <<= 8;\n    }\n    return decodeURIComponent(escape(out));\n  },\n  \n  /** Convert from a UTF-8 string to a bitArray. */\n  toBits: function (str) {\n    str = unescape(encodeURIComponent(str));\n    var out = [], i, tmp=0;\n    for (i=0; i<str.length; i++) {\n      tmp = tmp << 8 | str.charCodeAt(i);\n      if ((i&3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n    if (i&3) {\n      out.push(sjcl.bitArray.partial(8*(i&3), tmp));\n    }\n    return out;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Hexadecimal */\nsjcl.codec.hex = {\n  /** Convert from a bitArray to a hex string. */\n  fromBits: function (arr) {\n    var out = \"\", i, x;\n    for (i=0; i<arr.length; i++) {\n      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);\n    }\n    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, \"$1 \");\n  },\n  /** Convert from a hex string to a bitArray. */\n  toBits: function (str) {\n    var i, out=[], len;\n    str = str.replace(/\\s|0x/g, \"\");\n    len = str.length;\n    str = str + \"00000000\";\n    for (i=0; i<str.length; i+=8) {\n      out.push(parseInt(str.substr(i,8),16)^0);\n    }\n    return sjcl.bitArray.clamp(out, len*4);\n  }\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Base64 encoding/decoding */\nsjcl.codec.base64 = {\n  /** The base64 alphabet.\n   * @private\n   */\n  _chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  \n  /** Convert from a bitArray to a base64 string. */\n  fromBits: function (arr, _noEquals, _url) {\n    var out = \"\", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);\n    if (_url) c = c.substr(0,62) + '-_';\n    for (i=0; out.length * 6 < bl; ) {\n      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);\n      if (bits < 6) {\n        ta = arr[i] << (6-bits);\n        bits += 26;\n        i++;\n      } else {\n        ta <<= 6;\n        bits -= 6;\n      }\n    }\n    while ((out.length & 3) && !_noEquals) { out += \"=\"; }\n    return out;\n  },\n  \n  /** Convert from a base64 string to a bitArray */\n  toBits: function(str, _url) {\n    str = str.replace(/\\s|=/g,'');\n    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;\n    if (_url) c = c.substr(0,62) + '-_';\n    for (i=0; i<str.length; i++) {\n      x = c.indexOf(str.charAt(i));\n      if (x < 0) {\n        throw new sjcl.exception.invalid(\"this isn't base64!\");\n      }\n      if (bits > 26) {\n        bits -= 26;\n        out.push(ta ^ x>>>bits);\n        ta  = x << (32-bits);\n      } else {\n        bits += 6;\n        ta ^= x << (32-bits);\n      }\n    }\n    if (bits&56) {\n      out.push(sjcl.bitArray.partial(bits&56, ta, 1));\n    }\n    return out;\n  }\n};\n\nsjcl.codec.base64url = {\n  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },\n  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Arrays of bytes */\nsjcl.codec.bytes = {\n  /** Convert from a bitArray to an array of bytes. */\n  fromBits: function (arr) {\n    var out = [], bl = sjcl.bitArray.bitLength(arr), i, tmp;\n    for (i=0; i<bl/8; i++) {\n      if ((i&3) === 0) {\n        tmp = arr[i/4];\n      }\n      out.push(tmp >>> 24);\n      tmp <<= 8;\n    }\n    return out;\n  },\n  /** Convert from an array of bytes to a bitArray. */\n  toBits: function (bytes) {\n    var out = [], i, tmp=0;\n    for (i=0; i<bytes.length; i++) {\n      tmp = tmp << 8 | bytes[i];\n      if ((i&3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n    if (i&3) {\n      out.push(sjcl.bitArray.partial(8*(i&3), tmp));\n    }\n    return out;\n  }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n * @class Secure Hash Algorithm, 256 bits.\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    for (i = 512+ol & -512; i <= nl; i+= 512) {\n      this._block(b.splice(0,16));\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    outer: for (; i<64; prime++) {\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          // not a prime\n          continue outer;\n        }\n      }\n      \n      if (i<8) {\n        this._init[i] = frac(Math.pow(prime, 1/2));\n      }\n      this._key[i] = frac(Math.pow(prime, 1/3));\n      i++;\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {  \n    var i, tmp, a, b,\n      w = words.slice(0),\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n * @class Secure Hash Algorithm, 160 bits.\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    for (i = this.blockSize+ol & -this.blockSize; i <= nl;\n         i+= this.blockSize) {\n      this._block(b.splice(0,16));\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {  \n    var t, tmp, a, b, c, d, e,\n    w = words.slice(0),\n    h = this._h,\n    k = this._key;\n   \n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n/** @fileOverview CCM mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace CTR mode with CBC MAC. */\nsjcl.mode.ccm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ccm\",\n  \n  /** Encrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function(prf, plaintext, iv, adata, tlen) {\n    var L, i, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;\n    tlen = tlen || 64;\n    adata = adata || [];\n    \n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n    \n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n    \n    // compute the tag\n    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);\n    \n    // encrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    \n    return w.concat(out.data, out.tag);\n  },\n  \n  /** Decrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [[]] adata The authenticated data.\n   * @param {Number} [64] tlen the desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function(prf, ciphertext, iv, adata, tlen) {\n    tlen = tlen || 64;\n    adata = adata || [];\n    var L, i, \n        w=sjcl.bitArray,\n        ivl = w.bitLength(iv) / 8,\n        ol = w.bitLength(ciphertext), \n        out = w.clamp(ciphertext, ol - tlen),\n        tag = w.bitSlice(ciphertext, ol - tlen), tag2;\n    \n\n    ol = (ol - tlen) / 8;\n        \n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n    \n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n    \n    // decrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    \n    // check the tag\n    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);\n    if (!w.equal(out.tag, tag2)) {\n      throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n    }\n    \n    return out.data;\n  },\n\n  /* Compute the (unencrypted) authentication tag, according to the CCM specification\n   * @param {Object} prf The pseudorandom function.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} adata The authenticated data.\n   * @param {Number} tlen the desired tag length, in bits.\n   * @return {bitArray} The tag, but not yet encrypted.\n   * @private\n   */\n  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {\n    // compute B[0]\n    var q, mac, field = 0, offset = 24, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;\n\n    tlen /= 8;\n  \n    // check tag length and message length\n    if (tlen % 2 || tlen < 4 || tlen > 16) {\n      throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n    }\n  \n    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {\n      // I don't want to deal with extracting high words from doubles.\n      throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n    }\n\n    // mac the flags\n    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];\n\n    // mac the iv and length\n    mac = w.concat(mac, iv);\n    mac[3] |= w.bitLength(plaintext)/8;\n    mac = prf.encrypt(mac);\n    \n  \n    if (adata.length) {\n      // mac the associated data.  start with its length...\n      tmp = w.bitLength(adata)/8;\n      if (tmp <= 0xFEFF) {\n        macData = [w.partial(16, tmp)];\n      } else if (tmp <= 0xFFFFFFFF) {\n        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);\n      } // else ...\n    \n      // mac the data itself\n      macData = w.concat(macData, adata);\n      for (i=0; i<macData.length; i += 4) {\n        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));\n      }\n    }\n  \n    // mac the plaintext\n    for (i=0; i<plaintext.length; i+=4) {\n      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));\n    }\n\n    return w.clamp(mac, tlen * 8);\n  },\n\n  /** CCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.\n   * May mutate its arguments.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} tag The authentication tag.\n   * @param {Number} tlen The length of th etag, in bits.\n   * @param {Number} L The CCM L value.\n   * @return {Object} An object with data and tag, the en/decryption of data and tag values.\n   * @private\n   */\n  _ctrMode: function(prf, data, iv, tag, tlen, L) {\n    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, b, l = data.length, bl=w.bitLength(data);\n\n    // start the ctr\n    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);\n    \n    // en/decrypt the tag\n    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);\n  \n    // en/decrypt the data\n    if (!l) { return {tag:tag, data:[]}; }\n    \n    for (i=0; i<l; i+=4) {\n      ctr[3]++;\n      enc = prf.encrypt(ctr);\n      data[i]   ^= enc[0];\n      data[i+1] ^= enc[1];\n      data[i+2] ^= enc[2];\n      data[i+3] ^= enc[3];\n    }\n    return { tag:tag, data:w.clamp(data,bl) };\n  }\n};\n/** @fileOverview CBC mode implementation\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace\n * Dangerous: CBC mode with PKCS#5 padding.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\nif (sjcl.beware === undefined) {\n  sjcl.beware = {};\n}\nsjcl.beware[\"CBC mode is dangerous because it doesn't protect message integrity.\"\n] = function() {\n  sjcl.mode.cbc = {\n    /** The name of the mode.\n     * @constant\n     */\n    name: \"cbc\",\n    \n    /** Encrypt in CBC mode with PKCS#5 padding.\n     * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n     * @param {bitArray} plaintext The plaintext data.\n     * @param {bitArray} iv The initialization value.\n     * @param {bitArray} [adata=[]] The authenticated data.  Must be empty.\n     * @return The encrypted data, an array of bytes.\n     * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits, or if any adata is specified.\n     */\n    encrypt: function(prp, plaintext, iv, adata) {\n      if (adata && adata.length) {\n        throw new sjcl.exception.invalid(\"cbc can't authenticate data\");\n      }\n      if (sjcl.bitArray.bitLength(iv) !== 128) {\n        throw new sjcl.exception.invalid(\"cbc iv must be 128 bits\");\n      }\n      var i,\n          w = sjcl.bitArray,\n          xor = w._xor4,\n          bl = w.bitLength(plaintext),\n          bp = 0,\n          output = [];\n\n      if (bl&7) {\n        throw new sjcl.exception.invalid(\"pkcs#5 padding only works for multiples of a byte\");\n      }\n    \n      for (i=0; bp+128 <= bl; i+=4, bp+=128) {\n        /* Encrypt a non-final block */\n        iv = prp.encrypt(xor(iv, plaintext.slice(i,i+4)));\n        output.splice(i,0,iv[0],iv[1],iv[2],iv[3]);\n      }\n      \n      /* Construct the pad. */\n      bl = (16 - ((bl >> 3) & 15)) * 0x1010101;\n\n      /* Pad and encrypt. */\n      iv = prp.encrypt(xor(iv,w.concat(plaintext,[bl,bl,bl,bl]).slice(i,i+4)));\n      output.splice(i,0,iv[0],iv[1],iv[2],iv[3]);\n      return output;\n    },\n    \n    /** Decrypt in CBC mode.\n     * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n     * @param {bitArray} ciphertext The ciphertext data.\n     * @param {bitArray} iv The initialization value.\n     * @param {bitArray} [adata=[]] The authenticated data.  It must be empty.\n     * @return The decrypted data, an array of bytes.\n     * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits, or if any adata is specified.\n     * @throws {sjcl.exception.corrupt} if if the message is corrupt.\n     */\n    decrypt: function(prp, ciphertext, iv, adata) {\n      if (adata && adata.length) {\n        throw new sjcl.exception.invalid(\"cbc can't authenticate data\");\n      }\n      if (sjcl.bitArray.bitLength(iv) !== 128) {\n        throw new sjcl.exception.invalid(\"cbc iv must be 128 bits\");\n      }\n      if ((sjcl.bitArray.bitLength(ciphertext) & 127) || !ciphertext.length) {\n        throw new sjcl.exception.corrupt(\"cbc ciphertext must be a positive multiple of the block size\");\n      }\n      var i,\n          w = sjcl.bitArray,\n          xor = w._xor4,\n          bi, bo,\n          output = [];\n          \n      adata = adata || [];\n    \n      for (i=0; i<ciphertext.length; i+=4) {\n        bi = ciphertext.slice(i,i+4);\n        bo = xor(iv,prp.decrypt(bi));\n        output.splice(i,0,bo[0],bo[1],bo[2],bo[3]);\n        iv = bi;\n      }\n\n      /* check and remove the pad */\n      bi = output[i-1] & 255;\n      if (bi == 0 || bi > 16) {\n        throw new sjcl.exception.corrupt(\"pkcs#5 padding corrupt\");\n      }\n      bo = bi * 0x1010101;\n      if (!w.equal(w.bitSlice([bo,bo,bo,bo], 0, bi*8),\n                   w.bitSlice(output, output.length*32 - bi*8, output.length*32))) {\n        throw new sjcl.exception.corrupt(\"pkcs#5 padding corrupt\");\n      }\n\n      return w.bitSlice(output, 0, output.length*32 - bi*8);\n    }\n  };\n};\n/** @fileOverview OCB 2.0 implementation\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace\n * Phil Rogaway's Offset CodeBook mode, version 2.0.\n * May be covered by US and international patents.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\nsjcl.mode.ocb2 = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ocb2\",\n  \n  /** Encrypt in OCB mode, version 2.0.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param [false] premac 1 if the authentication data is pre-macced with PMAC.\n   * @return The encrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   */\n  encrypt: function(prp, plaintext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        output = [],\n        pad;\n        \n    adata = adata || [];\n    tlen  = tlen || 64;\n  \n    for (i=0; i+4 < plaintext.length; i+=4) {\n      /* Encrypt a non-final block */\n      bi = plaintext.slice(i,i+4);\n      checksum = xor(checksum, bi);\n      output = output.concat(xor(delta,prp.encrypt(xor(delta, bi))));\n      delta = times2(delta);\n    }\n    \n    /* Chop out the final block */\n    bi = plaintext.slice(i);\n    bl = w.bitLength(bi);\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = w.clamp(xor(bi.concat([0,0,0]),pad), bl);\n    \n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum,xor(bi.concat([0,0,0]),pad));\n    checksum = prp.encrypt(xor(checksum,xor(delta,times2(delta))));\n    \n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n    \n    return output.concat(w.concat(bi, w.clamp(checksum, tlen)));\n  },\n  \n  /** Decrypt in OCB mode.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.\n   * @return The decrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   * @throws {sjcl.exception.corrupt} if if the message is corrupt.\n   */\n  decrypt: function(prp, ciphertext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    tlen  = tlen || 64;\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        len = sjcl.bitArray.bitLength(ciphertext) - tlen,\n        output = [],\n        pad;\n        \n    adata = adata || [];\n  \n    for (i=0; i+4 < len/32; i+=4) {\n      /* Decrypt a non-final block */\n      bi = xor(delta, prp.decrypt(xor(delta, ciphertext.slice(i,i+4))));\n      checksum = xor(checksum, bi);\n      output = output.concat(bi);\n      delta = times2(delta);\n    }\n    \n    /* Chop out and decrypt the final block */\n    bl = len-i*32;\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = xor(pad, w.clamp(ciphertext.slice(i),bl).concat([0,0,0]));\n    \n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum, bi);\n    checksum = prp.encrypt(xor(checksum, xor(delta, times2(delta))));\n    \n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n    \n    if (!w.equal(w.clamp(checksum, tlen), w.bitSlice(ciphertext, len))) {\n      throw new sjcl.exception.corrupt(\"ocb: tag doesn't match\");\n    }\n    \n    return output.concat(w.clamp(bi,bl));\n  },\n  \n  /** PMAC authentication for OCB associated data.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} adata The authenticated data.\n   */\n  pmac: function(prp, adata) {\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = prp.encrypt([0,0,0,0]),\n        bi;\n        \n    delta = xor(delta,times2(times2(delta)));\n \n    for (i=0; i+4<adata.length; i+=4) {\n      delta = times2(delta);\n      checksum = xor(checksum, prp.encrypt(xor(delta, adata.slice(i,i+4))));\n    }\n    \n    bi = adata.slice(i);\n    if (w.bitLength(bi) < 128) {\n      delta = xor(delta,times2(delta));\n      bi = w.concat(bi,[0x80000000|0,0,0,0]);\n    }\n    checksum = xor(checksum, bi);\n    return prp.encrypt(xor(times2(xor(delta,times2(delta))), checksum));\n  },\n  \n  /** Double a block of words, OCB style.\n   * @private\n   */\n  _times2: function(x) {\n    return [x[0]<<1 ^ x[1]>>>31,\n            x[1]<<1 ^ x[2]>>>31,\n            x[2]<<1 ^ x[3]>>>31,\n            x[3]<<1 ^ (x[0]>>>31)*0x87];\n  }\n};\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n * @param {Codec} [encoding] the encoding function to use.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data, encoding) {\n  var w = new (this._hash)(this._baseHash[0]).update(data, encoding).finalize();\n  return new (this._hash)(this._baseHash[1]).update(w).finalize();\n};\n\n/** @fileOverview Password-based key-derivation function, version 2.0.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Password-Based Key-Derivation Function, version 2.0.\n *\n * Generate keys from passwords using PBKDF2-HMAC-SHA256.\n *\n * This is the method specified by RSA's PKCS #5 standard.\n *\n * @param {bitArray|String} password  The password.\n * @param {bitArray} salt The salt.  Should have lots of entropy.\n * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.\n * @param {Number} [length] The length of the derived key.  Defaults to the\n                            output size of the hash function.\n * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.\n * @return {bitArray} the derived key.\n */\nsjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {\n  count = count || 1000;\n  \n  if (length < 0 || count < 0) {\n    throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\n  }\n  \n  if (typeof password === \"string\") {\n    password = sjcl.codec.utf8String.toBits(password);\n  }\n  \n  Prff = Prff || sjcl.misc.hmac;\n  \n  var prf = new Prff(password),\n      u, ui, i, j, k, out = [], b = sjcl.bitArray;\n\n  for (k = 1; 32 * out.length < (length || 1); k++) {\n    u = ui = prf.encrypt(b.concat(salt,[k]));\n    \n    for (i=1; i<count; i++) {\n      ui = prf.encrypt(ui);\n      for (j=0; j<ui.length; j++) {\n        u[j] ^= ui[j];\n      }\n    }\n    \n    out = out.concat(u);\n  }\n\n  if (length) { out = b.clamp(out, length); }\n\n  return out;\n};\n/** @fileOverview Random number generator.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Random number generator\n *\n * @description\n * <p>\n * This random number generator is a derivative of Ferguson and Schneier's\n * generator Fortuna.  It collects entropy from various events into several\n * pools, implemented by streaming SHA-256 instances.  It differs from\n * ordinary Fortuna in a few ways, though.\n * </p>\n *\n * <p>\n * Most importantly, it has an entropy estimator.  This is present because\n * there is a strong conflict here between making the generator available\n * as soon as possible, and making sure that it doesn't \"run on empty\".\n * In Fortuna, there is a saved state file, and the system is likely to have\n * time to warm up.\n * </p>\n *\n * <p>\n * Second, because users are unlikely to stay on the page for very long,\n * and to speed startup time, the number of pools increases logarithmically:\n * a new pool is created when the previous one is actually used for a reseed.\n * This gives the same asymptotic guarantees as Fortuna, but gives more\n * entropy to early reseeds.\n * </p>\n *\n * <p>\n * The entire mechanism here feels pretty klunky.  Furthermore, there are\n * several improvements that should be made, including support for\n * dedicated cryptographic functions that may be present in some browsers;\n * state files in local storage; cookies containing randomness; etc.  So\n * look for improvements in future versions.\n * </p>\n */\nsjcl.random = {\n  /** Generate several random words, and return them in an array\n   * @param {Number} nwords The number of words to generate.\n   */\n  randomWords: function (nwords, paranoia) {\n    var out = [], i, readiness = this.isReady(paranoia), g;\n  \n    if (readiness === this._NOT_READY) {\n      throw new sjcl.exception.notReady(\"generator isn't seeded\");\n    } else if (readiness & this._REQUIRES_RESEED) {\n      this._reseedFromPools(!(readiness & this._READY));\n    }\n  \n    for (i=0; i<nwords; i+= 4) {\n      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {\n        this._gate();\n      }\n   \n      g = this._gen4words();\n      out.push(g[0],g[1],g[2],g[3]);\n    }\n    this._gate();\n  \n    return out.slice(0,nwords);\n  },\n  \n  setDefaultParanoia: function (paranoia) {\n    this._defaultParanoia = paranoia;\n  },\n  \n  /**\n   * Add entropy to the pools.\n   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string\n   * @param {Number} estimatedEntropy The estimated entropy of data, in bits\n   * @param {String} source The source of the entropy, eg \"mouse\"\n   */\n  addEntropy: function (data, estimatedEntropy, source) {\n    source = source || \"user\";\n  \n    var id,\n      i, tmp,\n      t = (new Date()).valueOf(),\n      robin = this._robins[source],\n      oldReady = this.isReady(), err = 0;\n      \n    id = this._collectorIds[source];\n    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }\n      \n    if (robin === undefined) { robin = this._robins[source] = 0; }\n    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;\n  \n    switch(typeof(data)) {\n      \n    case \"number\":\n      if (estimatedEntropy === undefined) {\n        estimatedEntropy = 1;\n      }\n      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);\n      break;\n      \n    case \"object\":\n      var objName = Object.prototype.toString.call(data);\n      if (objName === \"[object Uint32Array]\") {\n        tmp = [];\n        for (i = 0; i < data.length; i++) {\n          tmp.push(data[i]);\n        }\n        data = tmp;\n      } else {\n        if (objName !== \"[object Array]\") {\n          err = 1;\n        }\n        for (i=0; i<data.length && !err; i++) {\n          if (typeof(data[i]) != \"number\") {\n            err = 1;\n          }\n        }\n      }\n      if (!err) {\n        if (estimatedEntropy === undefined) {\n          /* horrible entropy estimator */\n          estimatedEntropy = 0;\n          for (i=0; i<data.length; i++) {\n            tmp= data[i];\n            while (tmp>0) {\n              estimatedEntropy++;\n              tmp = tmp >>> 1;\n            }\n          }\n        }\n        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));\n      }\n      break;\n      \n    case \"string\":\n      if (estimatedEntropy === undefined) {\n       /* English text has just over 1 bit per character of entropy.\n        * But this might be HTML or something, and have far less\n        * entropy than English...  Oh well, let's just say one bit.\n        */\n       estimatedEntropy = data.length;\n      }\n      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);\n      this._pools[robin].update(data);\n      break;\n      \n    default:\n      err=1;\n    }\n    if (err) {\n      throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n    }\n  \n    /* record the new strength */\n    this._poolEntropy[robin] += estimatedEntropy;\n    this._poolStrength += estimatedEntropy;\n  \n    /* fire off events */\n    if (oldReady === this._NOT_READY) {\n      if (this.isReady() !== this._NOT_READY) {\n        this._fireEvent(\"seeded\", Math.max(this._strength, this._poolStrength));\n      }\n      this._fireEvent(\"progress\", this.getProgress());\n    }\n  },\n  \n  /** Is the generator ready? */\n  isReady: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];\n  \n    if (this._strength && this._strength >= entropyRequired) {\n      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?\n        this._REQUIRES_RESEED | this._READY :\n        this._READY;\n    } else {\n      return (this._poolStrength >= entropyRequired) ?\n        this._REQUIRES_RESEED | this._NOT_READY :\n        this._NOT_READY;\n    }\n  },\n  \n  /** Get the generator's progress toward readiness, as a fraction */\n  getProgress: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];\n  \n    if (this._strength >= entropyRequired) {\n      return 1.0;\n    } else {\n      return (this._poolStrength > entropyRequired) ?\n        1.0 :\n        this._poolStrength / entropyRequired;\n    }\n  },\n  \n  /** start the built-in entropy collectors */\n  startCollectors: function () {\n    if (this._collectorsStarted) { return; }\n  \n    if (window.addEventListener) {\n      window.addEventListener(\"load\", this._loadTimeCollector, false);\n      window.addEventListener(\"mousemove\", this._mouseCollector, false);\n    } else if (document.attachEvent) {\n      document.attachEvent(\"onload\", this._loadTimeCollector);\n      document.attachEvent(\"onmousemove\", this._mouseCollector);\n    }\n    else {\n      throw new sjcl.exception.bug(\"can't attach event\");\n    }\n  \n    this._collectorsStarted = true;\n  },\n  \n  /** stop the built-in entropy collectors */\n  stopCollectors: function () {\n    if (!this._collectorsStarted) { return; }\n  \n    if (window.removeEventListener) {\n      window.removeEventListener(\"load\", this._loadTimeCollector, false);\n      window.removeEventListener(\"mousemove\", this._mouseCollector, false);\n    } else if (window.detachEvent) {\n      window.detachEvent(\"onload\", this._loadTimeCollector);\n      window.detachEvent(\"onmousemove\", this._mouseCollector);\n    }\n    this._collectorsStarted = false;\n  },\n  \n  /* use a cookie to store entropy.\n  useCookie: function (all_cookies) {\n      throw new sjcl.exception.bug(\"random: useCookie is unimplemented\");\n  },*/\n  \n  /** add an event listener for progress or seeded-ness. */\n  addEventListener: function (name, callback) {\n    this._callbacks[name][this._callbackI++] = callback;\n  },\n  \n  /** remove an event listener for progress or seeded-ness */\n  removeEventListener: function (name, cb) {\n    var i, j, cbs=this._callbacks[name], jsTemp=[];\n  \n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n  \n    for (j in cbs) {\n\tif (cbs.hasOwnProperty(j) && cbs[j] === cb) {\n        jsTemp.push(j);\n      }\n    }\n  \n    for (i=0; i<jsTemp.length; i++) {\n      j = jsTemp[i];\n      delete cbs[j];\n    }\n  },\n  \n  /* private */\n  _pools                   : [new sjcl.hash.sha256()],\n  _poolEntropy             : [0],\n  _reseedCount             : 0,\n  _robins                  : {},\n  _eventId                 : 0,\n  \n  _collectorIds            : {},\n  _collectorIdNext         : 0,\n  \n  _strength                : 0,\n  _poolStrength            : 0,\n  _nextReseed              : 0,\n  _key                     : [0,0,0,0,0,0,0,0],\n  _counter                 : [0,0,0,0],\n  _cipher                  : undefined,\n  _defaultParanoia         : 6,\n  \n  /* event listener stuff */\n  _collectorsStarted       : false,\n  _callbacks               : {progress: {}, seeded: {}},\n  _callbackI               : 0,\n  \n  /* constants */\n  _NOT_READY               : 0,\n  _READY                   : 1,\n  _REQUIRES_RESEED         : 2,\n\n  _MAX_WORDS_PER_BURST     : 65536,\n  _PARANOIA_LEVELS         : [0,48,64,96,128,192,256,384,512,768,1024],\n  _MILLISECONDS_PER_RESEED : 30000,\n  _BITS_PER_RESEED         : 80,\n  \n  /** Generate 4 random words, no reseed, no gate.\n   * @private\n   */\n  _gen4words: function () {\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n    return this._cipher.encrypt(this._counter);\n  },\n  \n  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.\n   * @private\n   */\n  _gate: function () {\n    this._key = this._gen4words().concat(this._gen4words());\n    this._cipher = new sjcl.cipher.aes(this._key);\n  },\n  \n  /** Reseed the generator with the given words\n   * @private\n   */\n  _reseed: function (seedWords) {\n    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));\n    this._cipher = new sjcl.cipher.aes(this._key);\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n  },\n  \n  /** reseed the data from the entropy pools\n   * @param full If set, use all the entropy pools in the reseed.\n   */\n  _reseedFromPools: function (full) {\n    var reseedData = [], strength = 0, i;\n  \n    this._nextReseed = reseedData[0] =\n      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;\n    \n    for (i=0; i<16; i++) {\n      /* On some browsers, this is cryptographically random.  So we might\n       * as well toss it in the pot and stir...\n       */\n      reseedData.push(Math.random()*0x100000000|0);\n    }\n    \n    for (i=0; i<this._pools.length; i++) {\n     reseedData = reseedData.concat(this._pools[i].finalize());\n     strength += this._poolEntropy[i];\n     this._poolEntropy[i] = 0;\n   \n     if (!full && (this._reseedCount & (1<<i))) { break; }\n    }\n  \n    /* if we used the last pool, push a new one onto the stack */\n    if (this._reseedCount >= 1 << this._pools.length) {\n     this._pools.push(new sjcl.hash.sha256());\n     this._poolEntropy.push(0);\n    }\n  \n    /* how strong was this reseed? */\n    this._poolStrength -= strength;\n    if (strength > this._strength) {\n      this._strength = strength;\n    }\n  \n    this._reseedCount ++;\n    this._reseed(reseedData);\n  },\n  \n  _mouseCollector: function (ev) {\n    var x = ev.x || ev.clientX || ev.offsetX || 0, y = ev.y || ev.clientY || ev.offsetY || 0;\n    sjcl.random.addEntropy([x,y], 2, \"mouse\");\n  },\n  \n  _loadTimeCollector: function (ev) {\n    sjcl.random.addEntropy((new Date()).valueOf(), 2, \"loadtime\");\n  },\n  \n  _fireEvent: function (name, arg) {\n    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];\n    /* TODO: there is a race condition between removing collectors and firing them */ \n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n  \n    for (j in cbs) {\n     if (cbs.hasOwnProperty(j)) {\n        cbsTemp.push(cbs[j]);\n     }\n    }\n  \n    for (j=0; j<cbsTemp.length; j++) {\n     cbsTemp[j](arg);\n    }\n  }\n};\n\n(function(){\n  try {\n    // get cryptographically strong entropy in Webkit\n    var ab = new Uint32Array(32);\n    crypto.getRandomValues(ab);\n    sjcl.random.addEntropy(ab, 1024, \"crypto.getRandomValues\");\n  } catch (e) {\n    // no getRandomValues :-(\n  }\n})();\n/** @fileOverview Convenince functions centered around JSON encapsulation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n \n /** @namespace JSON encapsulation */\n sjcl.json = {\n  /** Default values for encryption */\n  defaults: { v:1, iter:1000, ks:128, ts:64, mode:\"ccm\", adata:\"\", cipher:\"aes\" },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {String} The ciphertext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  encrypt: function (password, plaintext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n    \n    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },\n                                  j.defaults), tmp, prp, adata;\n    j._add(p, params);\n    adata = p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n    \n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n    }\n    \n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt = tmp.salt;\n    }\n    if (typeof plaintext === \"string\") {\n      plaintext = sjcl.codec.utf8String.toBits(plaintext);\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n    \n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n    \n    /* do the encryption */\n    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);\n    \n    //return j.encode(j._subtract(p, j.defaults));\n    return j.encode(p);\n  },\n  \n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} ciphertext The ciphertext to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  decrypt: function (password, ciphertext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n    \n    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),j.decode(ciphertext)), params, true), ct, tmp, prp, adata=p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n    \n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (!p.iv) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n    }\n    \n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt  = tmp.salt;\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n    \n    /* do the decryption */\n    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);\n    \n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n    \n    return sjcl.codec.utf8String.fromBits(ct);\n  },\n  \n  /** Encode a flat structure into a JSON string.\n   * @param {Object} obj The structure to encode.\n   * @return {String} A JSON string.\n   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.\n   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.\n   */\n  encode: function (obj) {\n    var i, out='{', comma='';\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (!i.match(/^[a-z0-9]+$/i)) {\n          throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n        }\n        out += comma + '\"' + i + '\"' + ':';\n        comma = ',';\n        \n        switch (typeof obj[i]) {\n        case 'number':\n        case 'boolean':\n          out += obj[i];\n          break;\n          \n        case 'string':\n          out += '\"' + escape(obj[i]) + '\"';\n          break;\n        \n        case 'object':\n          out += '\"' + sjcl.codec.base64.fromBits(obj[i],1) + '\"';\n          break;\n        \n        default:\n          throw new sjcl.exception.bug(\"json encode: unsupported type\");\n        }\n      }\n    }\n    return out+'}';\n  },\n  \n  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,\n   * adata, salt and iv will be base64-decoded.\n   * @param {String} str The string.\n   * @return {Object} The decoded structure.\n   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.\n   */\n  decode: function (str) {\n    str = str.replace(/\\s/g,'');\n    if (!str.match(/^\\{.*\\}$/)) { \n      throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n    }\n    var a = str.replace(/^\\{|\\}$/g, '').split(/,/), out={}, i, m;\n    for (i=0; i<a.length; i++) {\n      if (!(m=a[i].match(/^(?:([\"']?)([a-z][a-z0-9]*)\\1):(?:(\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\")$/i))) {\n        throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n      }\n      if (m[3]) {\n        out[m[2]] = parseInt(m[3],10);\n      } else {\n        out[m[2]] = m[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);\n      }\n    }\n    return out;\n  },\n  \n  /** Insert all elements of src into target, modifying and returning target.\n   * @param {Object} target The object to be modified.\n   * @param {Object} src The object to pull data from.\n   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.\n   * @return {Object} target.\n   * @private\n   */\n  _add: function (target, src, requireSame) {\n    if (target === undefined) { target = {}; }\n    if (src === undefined) { return target; }\n    var i;\n    for (i in src) {\n      if (src.hasOwnProperty(i)) {\n        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {\n          throw new sjcl.exception.invalid(\"required parameter overridden\");\n        }\n        target[i] = src[i];\n      }\n    }\n    return target;\n  },\n  \n  /** Remove all elements of minus from plus.  Does not modify plus.\n   * @private\n   */\n  _subtract: function (plus, minus) {\n    var out = {}, i;\n    \n    for (i in plus) {\n      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {\n        out[i] = plus[i];\n      }\n    }\n    \n    return out;\n  },\n  \n  /** Return only the specified elements of src.\n   * @private\n   */\n  _filter: function (src, filter) {\n    var out = {}, i;\n    for (i=0; i<filter.length; i++) {\n      if (src[filter[i]] !== undefined) {\n        out[filter[i]] = src[filter[i]];\n      }\n    }\n    return out;\n  }\n};\n\n/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} plaintext The data to encrypt.\n * @param {Object} [params] The parameters including tag, iv and salt.\n * @param {Object} [rp] A returned version with filled-in parameters.\n * @return {String} The ciphertext.\n */\nsjcl.encrypt = sjcl.json.encrypt;\n\n/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} ciphertext The ciphertext to decrypt.\n * @param {Object} [params] Additional non-default parameters.\n * @param {Object} [rp] A returned object with filled parameters.\n * @return {String} The plaintext.\n */\nsjcl.decrypt = sjcl.json.decrypt;\n\n/** The cache for cachedPbkdf2.\n * @private\n */\nsjcl.misc._pbkdf2Cache = {};\n\n/** Cached PBKDF2 key derivation.\n * @param {String} password The password.\n * @param {Object} [params] The derivation params (iteration count and optional salt).\n * @return {Object} The derived data in key, the salt in salt.\n */\nsjcl.misc.cachedPbkdf2 = function (password, obj) {\n  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;\n  \n  obj = obj || {};\n  iter = obj.iter || 1000;\n  \n  /* open the cache for this password and iteration count */\n  cp = cache[password] = cache[password] || {};\n  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?\n                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };\n          \n  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;\n  \n  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);\n  return { key: c[salt].slice(0), salt:salt.slice(0) };\n};\n\n\n/**\n * Constructs a new bignum from another bignum, a number or a hex string.\n */\nsjcl.bn = function(it) {\n  this.initWith(it);\n};\n\nsjcl.bn.prototype = {\n  radix: 24,\n  maxMul: 8,\n  _class: sjcl.bn,\n  \n  copy: function() {\n    return new this._class(this);\n  },\n\n  /**\n   * Initializes this with it, either as a bn, a number, or a hex string.\n   */\n  initWith: function(it) {\n    var i=0, k, n, l;\n    switch(typeof it) {\n    case \"object\":\n      this.limbs = it.limbs.slice(0);\n      break;\n      \n    case \"number\":\n      this.limbs = [it];\n      this.normalize();\n      break;\n      \n    case \"string\":\n      it = it.replace(/^0x/, '');\n      this.limbs = [];\n      // hack\n      k = this.radix / 4;\n      for (i=0; i < it.length; i+=k) {\n        this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));\n      }\n      break;\n\n    default:\n      this.limbs = [0];\n    }\n    return this;\n  },\n\n  /**\n   * Returns true if \"this\" and \"that\" are equal.  Calls fullReduce().\n   * Equality test is in constant time.\n   */\n  equals: function(that) {\n    if (typeof that === \"number\") { that = new this._class(that); }\n    var difference = 0, i;\n    this.fullReduce();\n    that.fullReduce();\n    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {\n      difference |= this.getLimb(i) ^ that.getLimb(i);\n    }\n    return (difference === 0);\n  },\n  \n  /**\n   * Get the i'th limb of this, zero if i is too large.\n   */\n  getLimb: function(i) {\n    return (i >= this.limbs.length) ? 0 : this.limbs[i];\n  },\n  \n  /**\n   * Constant time comparison function.\n   * Returns 1 if this >= that, or zero otherwise.\n   */\n  greaterEquals: function(that) {\n    if (typeof that === \"number\") { that = new this._class(that); }\n    var less = 0, greater = 0, i, a, b;\n    i = Math.max(this.limbs.length, that.limbs.length) - 1;\n    for (; i>= 0; i--) {\n      a = this.getLimb(i);\n      b = that.getLimb(i);\n      greater |= (b - a) & ~less;\n      less |= (a - b) & ~greater;\n    }\n    return (greater | ~less) >>> 31;\n  },\n  \n  /**\n   * Convert to a hex string.\n   */\n  toString: function() {\n    this.fullReduce();\n    var out=\"\", i, s, l = this.limbs;\n    for (i=0; i < this.limbs.length; i++) {\n      s = l[i].toString(16);\n      while (i < this.limbs.length - 1 && s.length < 6) {\n        s = \"0\" + s;\n      }\n      out = s + out;\n    }\n    return \"0x\"+out;\n  },\n  \n  /** this += that.  Does not normalize. */\n  addM: function(that) {\n    if (typeof(that) !== \"object\") { that = new this._class(that); }\n    var i, l=this.limbs, ll=that.limbs;\n    for (i=l.length; i<ll.length; i++) {\n      l[i] = 0;\n    }\n    for (i=0; i<ll.length; i++) {\n      l[i] += ll[i];\n    }\n    return this;\n  },\n  \n  /** this *= 2.  Requires normalized; ends up normalized. */\n  doubleM: function() {\n    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;\n    for (i=0; i<l.length; i++) {\n      tmp = l[i];\n      tmp = tmp+tmp+carry;\n      l[i] = tmp & m;\n      carry = tmp >> r;\n    }\n    if (carry) {\n      l.push(carry);\n    }\n    return this;\n  },\n  \n  /** this /= 2, rounded down.  Requires normalized; ends up normalized. */\n  halveM: function() {\n    var i, carry=0, tmp, r=this.radix, l=this.limbs;\n    for (i=l.length-1; i>=0; i--) {\n      tmp = l[i];\n      l[i] = (tmp+carry)>>1;\n      carry = (tmp&1) << r;\n    }\n    if (!l[l.length-1]) {\n      l.pop();\n    }\n    return this;\n  },\n\n  /** this -= that.  Does not normalize. */\n  subM: function(that) {\n    if (typeof(that) !== \"object\") { that = new this._class(that); }\n    var i, l=this.limbs, ll=that.limbs;\n    for (i=l.length; i<ll.length; i++) {\n      l[i] = 0;\n    }\n    for (i=0; i<ll.length; i++) {\n      l[i] -= ll[i];\n    }\n    return this;\n  },\n  \n  mod: function(that) {\n    that = new sjcl.bn(that).normalize(); // copy before we begin\n    var out = new sjcl.bn(this).normalize(), ci=0;\n    \n    for (; out.greaterEquals(that); ci++) {\n      that.doubleM();\n    }\n    for (; ci > 0; ci--) {\n      that.halveM();\n      if (out.greaterEquals(that)) {\n        out.subM(that).normalize();\n      }\n    }\n    return out.trim();\n  },\n  \n  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */\n  inverseMod: function(p) {\n    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;\n    \n    if (!(p.limbs[0] & 1)) {\n      throw (new sjcl.exception.invalid(\"inverseMod: p must be odd\"));\n    }\n    \n    // invariant: y is odd\n    do {\n      if (x.limbs[0] & 1) {\n        if (!x.greaterEquals(y)) {\n          // x < y; swap everything\n          tmp = x; x = y; y = tmp;\n          tmp = a; a = b; b = tmp;\n        }\n        x.subM(y);\n        x.normalize();\n        \n        if (!a.greaterEquals(b)) {\n          a.addM(p);\n        }\n        a.subM(b);\n      }\n      \n      // cut everything in half\n      x.halveM();\n      if (a.limbs[0] & 1) {\n        a.addM(p);\n      }\n      a.normalize();\n      a.halveM();\n      \n      // check for termination: x ?= 0\n      for (i=nz=0; i<x.limbs.length; i++) {\n        nz |= x.limbs[i];\n      }\n    } while(nz);\n    \n    if (!y.equals(1)) {\n      throw (new sjcl.exception.invalid(\"inverseMod: p and x must be relatively prime\"));\n    }\n    \n    return b;\n  },\n  \n  /** this + that.  Does not normalize. */\n  add: function(that) {\n    return this.copy().addM(that);\n  },\n\n  /** this - that.  Does not normalize. */\n  sub: function(that) {\n    return this.copy().subM(that);\n  },\n  \n  /** this * that.  Normalizes and reduces. */\n  mul: function(that) {\n    if (typeof(that) === \"number\") { that = new this._class(that); }\n    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;\n\n    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {\n      c[i] = 0;\n    }\n    for (i=0; i<al; i++) {\n      ai = a[i];\n      for (j=0; j<bl; j++) {\n        c[i+j] += ai * b[j];\n      }\n     \n      if (!--ii) {\n        ii = this.maxMul;\n        out.cnormalize();\n      }\n    }\n    return out.cnormalize().reduce();\n  },\n\n  /** this ^ 2.  Normalizes and reduces. */\n  square: function() {\n    return this.mul(this);\n  },\n\n  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */\n  power: function(l) {\n    if (typeof(l) === \"number\") {\n      l = [l];\n    } else if (l.limbs !== undefined) {\n      l = l.normalize().limbs;\n    }\n    var i, j, out = new this._class(1), pow = this;\n\n    for (i=0; i<l.length; i++) {\n      for (j=0; j<this.radix; j++) {\n        if (l[i] & (1<<j)) {\n          out = out.mul(pow);\n        }\n        pow = pow.square();\n      }\n    }\n    \n    return out;\n  },\n\n  /** this * that mod N */\n  mulmod: function(that, N) {\n    return this.mod(N).mul(that.mod(N)).mod(N);\n  },\n\n  /** this ^ x mod N */\n  powermod: function(x, N) {\n    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);\n    while (true) {\n      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }\n      k.halveM();\n      if (k.equals(0)) { break; }\n      a = a.mulmod(a, N);\n    }\n    return result.normalize().reduce();\n  },\n\n  trim: function() {\n    var l = this.limbs, p;\n    do {\n      p = l.pop();\n    } while (l.length && p === 0);\n    l.push(p);\n    return this;\n  },\n  \n  /** Reduce mod a modulus.  Stubbed for subclassing. */\n  reduce: function() {\n    return this;\n  },\n\n  /** Reduce and normalize. */\n  fullReduce: function() {\n    return this.normalize();\n  },\n  \n  /** Propagate carries. */\n  normalize: function() {\n    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {\n      l = (limbs[i]||0) + carry;\n      m = limbs[i] = l & mask;\n      carry = (l-m)*ipv;\n    }\n    if (carry === -1) {\n      limbs[i-1] -= this.placeVal;\n    }\n    return this;\n  },\n\n  /** Constant-time normalize. Does not allocate additional space. */\n  cnormalize: function() {\n    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n    for (i=0; i < ll-1; i++) {\n      l = limbs[i] + carry;\n      m = limbs[i] = l & mask;\n      carry = (l-m)*ipv;\n    }\n    limbs[i] += carry;\n    return this;\n  },\n  \n  /** Serialize to a bit array */\n  toBits: function(len) {\n    this.fullReduce();\n    len = len || this.exponent || this.limbs.length * this.radix;\n    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,\n        out = [w.partial(e, this.getLimb(i))];\n    for (i--; i >= 0; i--) {\n      out = w.concat(out, [w.partial(this.radix, this.getLimb(i))]);\n    }\n    return out;\n  },\n  \n  /** Return the length in bits, rounded up to the nearest byte. */\n  bitLength: function() {\n    this.fullReduce();\n    var out = this.radix * (this.limbs.length - 1),\n        b = this.limbs[this.limbs.length - 1];\n    for (; b; b >>= 1) {\n      out ++;\n    }\n    return out+7 & -8;\n  }\n};\n\nsjcl.bn.fromBits = function(bits) {\n  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,\n      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;\n  \n  words[0] = w.extract(bits, 0, e);\n  for (; e < l; e += t.radix) {\n    words.unshift(w.extract(bits, e, t.radix));\n  }\n\n  out.limbs = words;\n  return out;\n};\n\n\n\nsjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));\nsjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;\n\n/**\n * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,\n * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.\n */\nsjcl.bn.pseudoMersennePrime = function(exponent, coeff) {\n  function p(it) {\n    this.initWith(it);\n    /*if (this.limbs[this.modOffset]) {\n      this.reduce();\n    }*/\n  }\n\n  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;\n  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);\n  ppr.exponent = exponent;\n  ppr.offset = [];\n  ppr.factor = [];\n  ppr.minOffset = mo;\n  ppr.fullMask = 0;\n  ppr.fullOffset = [];\n  ppr.fullFactor = [];\n  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));\n  \n  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);\n\n  for (i=0; i<coeff.length; i++) {\n    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);\n    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);\n    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);\n    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);\n    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));\n    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative\n  }\n  ppr._class = p;\n  ppr.modulus.cnormalize();\n\n  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p. */\n  ppr.reduce = function() {\n    var i, k, l, mo = this.modOffset, limbs = this.limbs, aff, off = this.offset, ol = this.offset.length, fac = this.factor, ll;\n\n    i = this.minOffset;\n    while (limbs.length > mo) {\n      l = limbs.pop();\n      ll = limbs.length;\n      for (k=0; k<ol; k++) {\n        limbs[ll+off[k]] -= fac[k] * l;\n      }\n      \n      i--;\n      if (!i) {\n        limbs.push(0);\n        this.cnormalize();\n        i = this.minOffset;\n      }\n    }\n    this.cnormalize();\n\n    return this;\n  };\n  \n  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {\n    var limbs = this.limbs, i = limbs.length - 1, k, l;\n    this.reduce();\n    if (i === this.modOffset - 1) {\n      l = limbs[i] & this.fullMask;\n      limbs[i] -= l;\n      for (k=0; k<this.fullOffset.length; k++) {\n        limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;\n      }\n      this.normalize();\n    }\n  };\n\n  /** mostly constant-time, very expensive full reduction. */\n  ppr.fullReduce = function() {\n    var greater, i;\n    // massively above the modulus, may be negative\n    \n    this._strongReduce();\n    // less than twice the modulus, may be negative\n\n    this.addM(this.modulus);\n    this.addM(this.modulus);\n    this.normalize();\n    // probably 2-3x the modulus\n    \n    this._strongReduce();\n    // less than the power of 2.  still may be more than\n    // the modulus\n\n    // HACK: pad out to this length\n    for (i=this.limbs.length; i<this.modOffset; i++) {\n      this.limbs[i] = 0;\n    }\n    \n    // constant-time subtract modulus\n    greater = this.greaterEquals(this.modulus);\n    for (i=0; i<this.limbs.length; i++) {\n      this.limbs[i] -= this.modulus.limbs[i] * greater;\n    }\n    this.cnormalize();\n\n    return this;\n  };\n\n  ppr.inverse = function() {\n    return (this.power(this.modulus.sub(2)));\n  };\n\n  p.fromBits = sjcl.bn.fromBits;\n\n  return p;\n};\n\n// a small Mersenne prime\nsjcl.bn.prime = {\n  p127: sjcl.bn.pseudoMersennePrime(127, [[0,-1]]),\n\n  // Bernstein's prime for Curve25519\n  p25519: sjcl.bn.pseudoMersennePrime(255, [[0,-19]]),\n\n  // NIST primes\n  p192: sjcl.bn.pseudoMersennePrime(192, [[0,-1],[64,-1]]),\n  p224: sjcl.bn.pseudoMersennePrime(224, [[0,1],[96,-1]]),\n  p256: sjcl.bn.pseudoMersennePrime(256, [[0,-1],[96,1],[192,1],[224,-1]]),\n  p384: sjcl.bn.pseudoMersennePrime(384, [[0,-1],[32,1],[96,-1],[128,-1]]),\n  p521: sjcl.bn.pseudoMersennePrime(521, [[0,-1]])\n};\n\nsjcl.bn.random = function(modulus, paranoia) {\n  if (typeof modulus !== \"object\") { modulus = new sjcl.bn(modulus); }\n  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();\n  while (true) {\n    // get a sequence whose first digits make sense\n    do {\n      words = sjcl.random.randomWords(l, paranoia);\n      if (words[l-1] < 0) { words[l-1] += 0x100000000; }\n    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));\n    words[l-1] %= m;\n\n    // mask off all the limbs\n    for (i=0; i<l-1; i++) {\n      words[i] &= modulus.radixMask;\n    }\n\n    // check the rest of the digitssj\n    out.limbs = words;\n    if (!out.greaterEquals(modulus)) {\n      return out;\n    }\n  }\n};\n\nsjcl.ecc = {};\n\n/**\n * Represents a point on a curve in affine coordinates.\n * @constructor\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n * @param {bigInt} x The x coordinate.\n * @param {bigInt} y The y coordinate.\n */\nsjcl.ecc.point = function(curve,x,y) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.isIdentity = false;\n  }\n  this.curve = curve;\n};\n\n\n\nsjcl.ecc.point.prototype = {\n  toJac: function() {\n    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));\n  },\n\n  mult: function(k) {\n    return this.toJac().mult(k, this).toAffine();\n  },\n  \n  /**\n   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply this by.\n   * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n   * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n   */\n  mult2: function(k, k2, affine2) {\n    return this.toJac().mult2(k, this, k2, affine2).toAffine();\n  },\n  \n  multiples: function() {\n    var m, i, j;\n    if (this._multiples === undefined) {\n      j = this.toJac().doubl();\n      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];\n      for (i=3; i<16; i++) {\n        j = j.add(this);\n        m.push(j.toAffine());\n      }\n    }\n    return this._multiples;\n  },\n\n  isValid: function() {\n    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));\n  },\n\n  toBits: function() {\n    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());\n  }\n};\n\n/**\n * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which\n * will be converted to bigInts).\n *\n * @constructor\n * @param {bigInt/string} x The x coordinate.\n * @param {bigInt/string} y The y coordinate.\n * @param {bigInt/string} z The z coordinate.\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n */\nsjcl.ecc.pointJac = function(curve, x, y, z) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isIdentity = false;\n  }\n  this.curve = curve;\n};\n\nsjcl.ecc.pointJac.prototype = {\n  /**\n   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.\n   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.\n   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. \n   */\n  add: function(T) {\n    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;\n    if (S.curve !== T.curve) {\n      throw(\"sjcl.ecc.add(): Points must be on the same curve to add them!\");\n    }\n\n    if (S.isIdentity) {\n      return T.toJac();\n    } else if (T.isIdentity) {\n      return S;\n    }\n\n    sz2 = S.z.square();\n    c = T.x.mul(sz2).subM(S.x);\n\n    if (c.equals(0)) {\n      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {\n        // same point\n        return S.doubl();\n      } else {\n        // inverses\n        return new sjcl.ecc.pointJac(S.curve);\n      }\n    }\n    \n    d = T.y.mul(sz2.mul(S.z)).subM(S.y);\n    c2 = c.square();\n\n    x1 = d.square();\n    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );\n    x  = x1.subM(x2);\n\n    y1 = S.x.mul(c2).subM(x).mul(d);\n    y2 = S.y.mul(c.square().mul(c));\n    y  = y1.subM(y2);\n\n    z  = S.z.mul(c);\n\n    return new sjcl.ecc.pointJac(this.curve,x,y,z);\n  },\n  \n  /**\n   * doubles this point.\n   * @return {sjcl.ecc.pointJac} The doubled point.\n   */\n  doubl: function() {\n    if (this.isIdentity) { return this; }\n\n    var\n      y2 = this.y.square(),\n      a  = y2.mul(this.x.mul(4)),\n      b  = y2.square().mul(8),\n      z2 = this.z.square(),\n      c  = this.x.sub(z2).mul(3).mul(this.x.add(z2)),\n      x  = c.square().subM(a).subM(a),\n      y  = a.sub(x).mul(c).subM(b),\n      z  = this.y.add(this.y).mul(this.z);\n    return new sjcl.ecc.pointJac(this.curve, x, y, z);\n  },\n\n  /**\n   * Returns a copy of this point converted to affine coordinates.\n   * @return {sjcl.ecc.point} The converted point.\n   */  \n  toAffine: function() {\n    if (this.isIdentity || this.z.equals(0)) {\n      return new sjcl.ecc.point(this.curve);\n    }\n    var zi = this.z.inverse(), zi2 = zi.square();\n    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());\n  },\n  \n  /**\n   * Multiply this point by k and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply by.\n   * @param {sjcl.ecc.point} affine This point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.\n   */\n  mult: function(k, affine) {\n    if (typeof(k) === \"number\") {\n      k = [k];\n    } else if (k.limbs !== undefined) {\n      k = k.normalize().limbs;\n    }\n    \n    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();\n\n    for (i=k.length-1; i>=0; i--) {\n      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {\n        out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);\n      }\n    }\n    \n    return out;\n  },\n  \n  /**\n   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply this by.\n   * @param {sjcl.ecc.point} affine This point in affine coordinates.\n   * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n   * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n   */\n  mult2: function(k1, affine, k2, affine2) {\n    if (typeof(k1) === \"number\") {\n      k1 = [k1];\n    } else if (k1.limbs !== undefined) {\n      k1 = k1.normalize().limbs;\n    }\n    \n    if (typeof(k2) === \"number\") {\n      k2 = [k2];\n    } else if (k2.limbs !== undefined) {\n      k2 = k2.normalize().limbs;\n    }\n    \n    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),\n        m2 = affine2.multiples(), l1, l2;\n\n    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {\n      l1 = k1[i] | 0;\n      l2 = k2[i] | 0;\n      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {\n        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);\n      }\n    }\n    \n    return out;\n  },\n\n  isValid: function() {\n    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);\n    return this.y.square().equals(\n             this.curve.b.mul(z6).add(this.x.mul(\n               this.curve.a.mul(z4).add(this.x.square()))));\n  }\n};\n\n/**\n * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.\n *\n * @constructor\n * @param {bigInt} p The prime modulus.\n * @param {bigInt} r The prime order of the curve.\n * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).\n * @param {bigInt} x The x coordinate of a base point of the curve.\n * @param {bigInt} y The y coordinate of a base point of the curve.\n */\nsjcl.ecc.curve = function(Field, r, a, b, x, y) {\n  this.field = Field;\n  this.r = Field.prototype.modulus.sub(r);\n  this.a = new Field(a);\n  this.b = new Field(b);\n  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));\n};\n\nsjcl.ecc.curve.prototype.fromBits = function (bits) {\n  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,\n      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),\n                             this.field.fromBits(w.bitSlice(bits, l, 2*l)));\n  if (!p.isValid()) {\n    throw new sjcl.exception.corrupt(\"not on the curve!\");\n  }\n  return p;\n};\n\nsjcl.ecc.curves = {\n  c192: new sjcl.ecc.curve(\n    sjcl.bn.prime.p192,\n    \"0x662107c8eb94364e4b2dd7ce\",\n    -3,\n    \"0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\",\n    \"0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\",\n    \"0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\"),\n\n  c224: new sjcl.ecc.curve(\n    sjcl.bn.prime.p224,\n    \"0xe95c1f470fc1ec22d6baa3a3d5c4\",\n    -3,\n    \"0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\",\n    \"0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\",\n    \"0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\"),\n\n  c256: new sjcl.ecc.curve(\n    sjcl.bn.prime.p256,\n    \"0x4319055358e8617b0c46353d039cdaae\",\n    -3,\n    \"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\",\n    \"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\",\n    \"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n\n  c384: new sjcl.ecc.curve(\n    sjcl.bn.prime.p384,\n    \"0x389cb27e0bc8d21fa7e5f24cb74f58851313e696333ad68c\",\n    -3,\n    \"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\",\n    \"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\",\n    \"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\")\n};\n\n\n/* Diffie-Hellman-like public-key system */\nsjcl.ecc._dh = function(cn) {\n  sjcl.ecc[cn] = {\n    publicKey: function(curve, point) {\n      this._curve = curve;\n      if (point instanceof Array) {\n        this._point = curve.fromBits(point);\n      } else {\n        this._point = point;\n      }\n    },\n\n    secretKey: function(curve, exponent) {\n      this._curve = curve;\n      this._exponent = exponent;\n    },\n\n    generateKeys: function(curve, paranoia) {\n      if (curve === undefined) {\n        curve = 256;\n      }\n      if (typeof curve === \"number\") {\n        curve = sjcl.ecc.curves['c'+curve];\n        if (curve === undefined) {\n          throw new sjcl.exception.invalid(\"no such curve\");\n        }\n      }\n      var sec = sjcl.bn.random(curve.r, paranoia), pub = curve.G.mult(sec);\n      return { pub: new sjcl.ecc[cn].publicKey(curve, pub),\n               sec: new sjcl.ecc[cn].secretKey(curve, sec) };\n    }\n  }; \n};\n\nsjcl.ecc._dh(\"elGamal\");\n\nsjcl.ecc.elGamal.publicKey.prototype = {\n  kem: function(paranoia) {\n    var sec = sjcl.bn.random(this._curve.r, paranoia),\n        tag = this._curve.G.mult(sec).toBits(),\n        key = sjcl.hash.sha256.hash(this._point.mult(sec).toBits());\n    return { key: key, tag: tag };\n  }\n};\n\nsjcl.ecc.elGamal.secretKey.prototype = {\n  unkem: function(tag) {\n    return sjcl.hash.sha256.hash(this._curve.fromBits(tag).mult(this._exponent).toBits());\n  },\n\n  dh: function(pk) {\n    return sjcl.hash.sha256.hash(pk._point.mult(this._exponent).toBits());\n  }\n};\n\nsjcl.ecc._dh(\"ecdsa\");\n\nsjcl.ecc.ecdsa.secretKey.prototype = {\n  sign: function(hash, paranoia) {\n    var R = this._curve.r,\n        l = R.bitLength(),\n        k = sjcl.bn.random(R.sub(1), paranoia).add(1),\n        r = this._curve.G.mult(k).x.mod(R),\n        s = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)).inverseMod(R).mul(k).mod(R);\n    return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));\n  }\n};\n\nsjcl.ecc.ecdsa.publicKey.prototype = {\n  verify: function(hash, rs) {\n    var w = sjcl.bitArray,\n        R = this._curve.r,\n        l = R.bitLength(),\n        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),\n        s = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),\n        hG = sjcl.bn.fromBits(hash).mul(s).mod(R),\n        hA = r.mul(s).mod(R),\n        r2 = this._curve.G.mult2(hG, hA, this._point).x;\n        \n    if (r.equals(0) || s.equals(0) || r.greaterEquals(R) || s.greaterEquals(R) || !r2.equals(r)) {\n      throw (new sjcl.exception.corrupt(\"signature didn't check out\"));\n    }\n    return true;\n  }\n};\n/** @fileOverview Javascript SRP implementation.\n *\n * This file contains a partial implementation of the SRP (Secure Remote\n * Password) password-authenticated key exchange protocol. Given a user\n * identity, salt, and SRP group, it generates the SRP verifier that may\n * be sent to a remote server to establish and SRP account.\n *\n * For more information, see http://srp.stanford.edu/.\n *\n * @author Quinn Slack\n */\n\n/**\n * Compute the SRP verifier from the username, password, salt, and group.\n * @class SRP\n */\nsjcl.keyexchange.srp = {\n  /**\n   * Calculates SRP v, the verifier. \n   *   v = g^x mod N [RFC 5054]\n   * @param {String} I The username.\n   * @param {String} P The password.\n   * @param {Object} s A bitArray of the salt.\n   * @param {Object} group The SRP group. Use sjcl.keyexchange.srp.knownGroup\n                           to obtain this object.\n   * @return {Object} A bitArray of SRP v.\n   */\n  makeVerifier: function(I, P, s, group) {\n    var x;\n    x = this.makeX(I, P, s);\n    x = sjcl.bn.fromBits(x);\n    return group.g.powermod(x, group.N);\n  },\n\n  /**\n   * Calculates SRP x.\n   *   x = SHA1(<salt> | SHA(<username> | \":\" | <raw password>)) [RFC 2945]\n   * @param {String} I The username.\n   * @param {String} P The password.\n   * @param {Object} s A bitArray of the salt.\n   * @return {Object} A bitArray of SRP x.\n   */\n  makeX: function(I, P, s) {\n    var inner = sjcl.hash.sha1.hash(I + ':' + P);\n    return sjcl.hash.sha1.hash(sjcl.bitArray.concat(s, inner));\n  },\n\n  /**\n   * Returns the known SRP group with the given size (in bits).\n   * @param {String} i The size of the known SRP group.\n   * @return {Object} An object with \"N\" and \"g\" properties.\n   */\n  knownGroup:function(i) {\n    if (typeof i !== \"string\") { i = i.toString(); }\n    if (!this._didInitKnownGroups) { this._initKnownGroups(); }\n    return this._knownGroups[i];\n  },\n\n  /**\n   * Initializes bignum objects for known group parameters.\n   * @private\n   */\n  _didInitKnownGroups: false,\n  _initKnownGroups:function() {\n    var i, size, group;\n    for (i=0; i < this._knownGroupSizes.length; i++) {\n      size = this._knownGroupSizes[i].toString();\n      group = this._knownGroups[size];\n      group.N = new sjcl.bn(group.N);\n      group.g = new sjcl.bn(group.g);\n    }\n    this._didInitKnownGroups = true;\n  },\n\n  _knownGroupSizes: [1024, 1536, 2048],\n  _knownGroups: {\n    1024: {\n      N: \"EEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C\" +\n         \"9C256576D674DF7496EA81D3383B4813D692C6E0E0D5D8E250B98BE4\" +\n         \"8E495C1D6089DAD15DC7D7B46154D6B6CE8EF4AD69B15D4982559B29\" +\n         \"7BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA9A\" +\n         \"FD5138FE8376435B9FC61D2FC0EB06E3\",\n      g:2\n    },\n\n    1536: {\n      N: \"9DEF3CAFB939277AB1F12A8617A47BBBDBA51DF499AC4C80BEEEA961\" +\n         \"4B19CC4D5F4F5F556E27CBDE51C6A94BE4607A291558903BA0D0F843\" +\n         \"80B655BB9A22E8DCDF028A7CEC67F0D08134B1C8B97989149B609E0B\" +\n         \"E3BAB63D47548381DBC5B1FC764E3F4B53DD9DA1158BFD3E2B9C8CF5\" +\n         \"6EDF019539349627DB2FD53D24B7C48665772E437D6C7F8CE442734A\" +\n         \"F7CCB7AE837C264AE3A9BEB87F8A2FE9B8B5292E5A021FFF5E91479E\" +\n         \"8CE7A28C2442C6F315180F93499A234DCF76E3FED135F9BB\",\n      g: 2\n    },\n\n    2048: {\n      N: \"AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC319294\" +\n         \"3DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310D\" +\n         \"CD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FB\" +\n         \"D5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF74\" +\n         \"7359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A\" +\n         \"436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D\" +\n         \"5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E73\" +\n         \"03CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB6\" +\n         \"94B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F\" +\n         \"9E4AFF73\",\n      g: 2\n    }\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// module.id = 7\n// module.realId = 3\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/sjcl/core.js");

/******/},
/******/
/******/4: function(module, exports, require) {

/******/ /* WEBPACK FREE VAR INJECTION */ (function(console) {
eval("Function.prototype.method = function(name,func) {\r\n  this.prototype[name] = func;\r\n\r\n  return this;\r\n};\r\n\r\nvar filterErr = function(code, done) {\r\n  return function(e) {\r\n      done(e.code !== code ? e : undefined);\r\n    };\r\n};\r\n\r\nvar throwErr = function(done) {\r\n  return function(e) {\r\n      if (e)\r\n\tthrow e;\r\n      \r\n      done();\r\n    };\r\n};\r\n \r\nvar trace = function(comment, func) {\r\n  return function() {\r\n      console.log(\"%s: %s\", trace, arguments.toString);\r\n      func(arguments);\r\n    };\r\n};\r\n\r\nvar arraySet = function (count, value) {\r\n  var a = new Array(count);\r\n  var i;\r\n\r\n  for (i = 0; i != count; i += 1)\r\n    a[i] = value;\r\n\r\n  return a;\r\n};\r\n\r\nvar hexToString = function (h) {\r\n  var\ta = [];\r\n  var\ti = 0;\r\n\r\n  if (h.length % 2) {\r\n    a.push(String.fromCharCode(parseInt(h.substring(0, 1), 16)));\r\n    i = 1;\r\n  }\r\n\r\n  for (; i != h.length; i += 2) {\r\n    a.push(String.fromCharCode(parseInt(h.substring(i, i+2), 16)));\r\n  }\r\n  \r\n  return a.join(\"\");\r\n};\r\n\r\nvar stringToHex = function (s) {\r\n  return Array.prototype.map.call(s, function (c) {\r\n      var b = c.charCodeAt(0);\r\n\r\n      return b < 16 ? \"0\" + b.toString(16) : b.toString(16);\r\n    }).join(\"\");\r\n};\r\n\r\nvar stringToArray = function (s) {\r\n  var a = new Array(s.length);\r\n  var i;\r\n\r\n  for (i = 0; i != a.length; i += 1)\r\n    a[i] = s.charCodeAt(i);\r\n\r\n  return a;\r\n};\r\n\r\nvar hexToArray = function (h) {\r\n  return stringToArray(hexToString(h));\r\n}\r\n\r\nvar chunkString = function (str, n, leftAlign) {\r\n  var ret = [];\r\n  var i=0, len=str.length;\r\n  if (leftAlign) {\r\n    i = str.length % n;\r\n    if (i) ret.push(str.slice(0, i));\r\n  }\r\n  for(; i < len; i += n) {\r\n    ret.push(str.slice(i, n+i));\r\n  }\r\n  return ret;\r\n};\r\n\r\nvar logObject = function (msg, obj) {\r\n  console.log(msg, JSON.stringify(obj, undefined, 2));\r\n};\r\n\r\nvar assert = function (assertion, msg) {\r\n  if (!assertion) {\r\n    throw new Error(\"Assertion failed\" + (msg ? \": \"+msg : \".\"));\r\n  }\r\n};\r\n\r\nexports.trace         = trace;\r\nexports.arraySet      = arraySet;\r\nexports.hexToString   = hexToString;\r\nexports.hexToArray    = hexToArray;\r\nexports.stringToArray = stringToArray;\r\nexports.stringToHex   = stringToHex;\r\nexports.chunkString   = chunkString;\r\nexports.logObject     = logObject;\r\nexports.assert        = assert;\r\n\r\n// vim:sw=2:sts=2:ts=8:et\r\n\n\n// WEBPACK FOOTER //\n// module.id = 8\n// module.realId = 4\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/utils.js");
/******/ /* WEBPACK FREE VAR INJECTION */ }(require(/* __webpack_console */1)))

/******/},
/******/
/******/5: function(module, exports, require) {

/******/ /* WEBPACK FREE VAR INJECTION */ (function(console) {
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nvar isArray = Array.isArray;\r\n\r\nfunction EventEmitter() { }\r\nexports.EventEmitter = EventEmitter;\r\n\r\n// By default EventEmitters will print a warning if more than\r\n// 10 listeners are added to it. This is a useful default which\r\n// helps finding memory leaks.\r\n//\r\n// Obviously not all Emitters should be limited to 10. This function allows\r\n// that to be increased. Set to zero for unlimited.\r\nvar defaultMaxListeners = 10;\r\nEventEmitter.prototype.setMaxListeners = function(n) {\r\n  if (!this._events) this._events = {};\r\n  this._maxListeners = n;\r\n};\r\n\r\n\r\nEventEmitter.prototype.emit = function() {\r\n  var type = arguments[0];\r\n  // If there is no 'error' event listener then throw.\r\n  if (type === 'error') {\r\n    if (!this._events || !this._events.error ||\r\n        (isArray(this._events.error) && !this._events.error.length))\r\n    {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (!this._events) return false;\r\n  var handler = this._events[type];\r\n  if (!handler) return false;\r\n\r\n  if (typeof handler == 'function') {\r\n    switch (arguments.length) {\r\n      // fast cases\r\n      case 1:\r\n        handler.call(this);\r\n        break;\r\n      case 2:\r\n        handler.call(this, arguments[1]);\r\n        break;\r\n      case 3:\r\n        handler.call(this, arguments[1], arguments[2]);\r\n        break;\r\n      // slower\r\n      default:\r\n        var l = arguments.length;\r\n        var args = new Array(l - 1);\r\n        for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n        handler.apply(this, args);\r\n    }\r\n    return true;\r\n\r\n  } else if (isArray(handler)) {\r\n    var l = arguments.length;\r\n    var args = new Array(l - 1);\r\n    for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\r\n    var listeners = handler.slice();\r\n    for (var i = 0, l = listeners.length; i < l; i++) {\r\n      listeners[i].apply(this, args);\r\n    }\r\n    return true;\r\n\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nEventEmitter.prototype.addListener = function(type, listener) {\r\n  if ('function' !== typeof listener) {\r\n    throw new Error('addListener only takes instances of Function');\r\n  }\r\n\r\n  if (!this._events) this._events = {};\r\n\r\n  // To avoid recursion in the case that type == \"newListeners\"! Before\r\n  // adding it to the listeners, first emit \"newListeners\".\r\n  this.emit('newListener', type, typeof listener.listener === 'function' ?\r\n            listener.listener : listener);\r\n\r\n  if (!this._events[type]) {\r\n    // Optimize the case of one listener. Don't need the extra array object.\r\n    this._events[type] = listener;\r\n  } else if (isArray(this._events[type])) {\r\n\r\n    // If we've already got an array, just append.\r\n    this._events[type].push(listener);\r\n\r\n  } else {\r\n    // Adding the second element, need to change to array.\r\n    this._events[type] = [this._events[type], listener];\r\n\r\n  }\r\n\r\n  // Check for listener leak\r\n  if (isArray(this._events[type]) && !this._events[type].warned) {\r\n    var m;\r\n    if (this._maxListeners !== undefined) {\r\n      m = this._maxListeners;\r\n    } else {\r\n      m = defaultMaxListeners;\r\n    }\r\n\r\n    if (m && m > 0 && this._events[type].length > m) {\r\n      this._events[type].warned = true;\r\n      console.error('(node) warning: possible EventEmitter memory ' +\r\n                    'leak detected. %d listeners added. ' +\r\n                    'Use emitter.setMaxListeners() to increase limit.',\r\n                    this._events[type].length);\r\n      console.trace();\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\r\nEventEmitter.prototype.once = function(type, listener) {\r\n  if ('function' !== typeof listener) {\r\n    throw new Error('.once only takes instances of Function');\r\n  }\r\n\r\n  var self = this;\r\n  function g() {\r\n    self.removeListener(type, g);\r\n    listener.apply(this, arguments);\r\n  };\r\n\r\n  g.listener = listener;\r\n  self.on(type, g);\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.removeListener = function(type, listener) {\r\n  if ('function' !== typeof listener) {\r\n    throw new Error('removeListener only takes instances of Function');\r\n  }\r\n\r\n  // does not use listeners(), so no side effect of creating _events[type]\r\n  if (!this._events || !this._events[type]) return this;\r\n\r\n  var list = this._events[type];\r\n\r\n  if (isArray(list)) {\r\n    var position = -1;\r\n    for (var i = 0, length = list.length; i < length; i++) {\r\n      if (list[i] === listener ||\r\n          (list[i].listener && list[i].listener === listener))\r\n      {\r\n        position = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (position < 0) return this;\r\n    list.splice(position, 1);\r\n    if (list.length == 0)\r\n      delete this._events[type];\r\n  } else if (list === listener ||\r\n             (list.listener && list.listener === listener))\r\n  {\r\n    delete this._events[type];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.removeAllListeners = function(type) {\r\n  if (arguments.length === 0) {\r\n    this._events = {};\r\n    return this;\r\n  }\r\n\r\n  // does not use listeners(), so no side effect of creating _events[type]\r\n  if (type && this._events && this._events[type]) this._events[type] = null;\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.listeners = function(type) {\r\n  if (!this._events) this._events = {};\r\n  if (!this._events[type]) this._events[type] = [];\r\n  if (!isArray(this._events[type])) {\r\n    this._events[type] = [this._events[type]];\r\n  }\r\n  return this._events[type];\r\n};\r\n\n\n// WEBPACK FOOTER //\n// module.id = 4\n// module.realId = 5\n// module.chunks = main\n//@ sourceURL=webpack-module:///(webpack)/buildin/web_modules/events.js");
/******/ /* WEBPACK FREE VAR INJECTION */ }(require(/* __webpack_console */1)))

/******/},
/******/
/******/6: function(module, exports, require) {

eval("// Derived from Tom Wu's jsbn code.\r\n//\r\n// Changes made for clean up and to package as a node.js module.\r\n\r\n// Copyright (c) 2005-2009  Tom Wu\r\n// All Rights Reserved.\r\n// See \"LICENSE\" for details.\r\n\r\n// Basic JavaScript BN library - subset useful for RSA encryption.\r\n// Extended JavaScript BN functions, required for RSA private ops.\r\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\r\n// Version 1.2: square() API, isProbablePrime fix\r\n\r\n// Bits per digit\r\nvar dbits;\r\n\r\n// JavaScript engine analysis\r\nvar canary = 0xdeadbeefcafe;\r\nvar j_lm = ((canary&0xffffff)==0xefcafe);\r\n\r\n// (public) Constructor\r\nvar BigInteger = function BigInteger(a,b,c) {\r\n  if(a != null)\r\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\r\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\r\n    else this.fromString(a,b);\r\n};\r\n\r\n// return new, unset BigInteger\r\nvar nbi\t= function nbi() { return new BigInteger(null); };\r\n\r\n// am: Compute w_j += (x*this_i), propagate carries,\r\n// c is initial carry, returns final carry.\r\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\r\n// We need to select the fastest one that works in this environment.\r\n\r\n// am1: use a single mult and divide to get the high bits,\r\n// max digit bits should be 26 because\r\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\r\nfunction am1(i,x,w,j,c,n) {\r\n  while(--n >= 0) {\r\n    var v = x*this[i++]+w[j]+c;\r\n    c = Math.floor(v/0x4000000);\r\n    w[j++] = v&0x3ffffff;\r\n  }\r\n  return c;\r\n}\r\n// am2 avoids a big mult-and-extract completely.\r\n// Max digit bits should be <= 30 because we do bitwise ops\r\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\r\nfunction am2(i,x,w,j,c,n) {\r\n  var xl = x&0x7fff, xh = x>>15;\r\n  while(--n >= 0) {\r\n    var l = this[i]&0x7fff;\r\n    var h = this[i++]>>15;\r\n    var m = xh*l+h*xl;\r\n    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\r\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\r\n    w[j++] = l&0x3fffffff;\r\n  }\r\n  return c;\r\n}\r\n// Alternately, set max digit bits to 28 since some\r\n// browsers slow down when dealing with 32-bit numbers.\r\nfunction am3(i,x,w,j,c,n) {\r\n  var xl = x&0x3fff, xh = x>>14;\r\n  while(--n >= 0) {\r\n    var l = this[i]&0x3fff;\r\n    var h = this[i++]>>14;\r\n    var m = xh*l+h*xl;\r\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\r\n    c = (l>>28)+(m>>14)+xh*h;\r\n    w[j++] = l&0xfffffff;\r\n  }\r\n  return c;\r\n}\r\n\r\nif(j_lm && 'undefined' !== typeof navigator && (navigator.appName == \"Microsoft Internet Explorer\")) {\r\n  BigInteger.prototype.am = am2;\r\n  dbits = 30;\r\n}\r\nelse if(j_lm && 'undefined' !== typeof navigator && (navigator.appName != \"Netscape\")) {\r\n  BigInteger.prototype.am = am1;\r\n  dbits = 26;\r\n}\r\nelse { // Mozilla/Netscape seems to prefer am3\r\n  BigInteger.prototype.am = am3;\r\n  dbits = 28;\r\n}\r\n\r\nBigInteger.prototype.DB = dbits;\r\nBigInteger.prototype.DM = ((1<<dbits)-1);\r\nBigInteger.prototype.DV = (1<<dbits);\r\n\r\nvar BI_FP = 52;\r\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\r\nBigInteger.prototype.F1 = BI_FP-dbits;\r\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\r\n\r\n// Digit conversions\r\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\nvar BI_RC = new Array();\r\nvar rr,vv;\r\nrr = \"0\".charCodeAt(0);\r\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\r\nrr = \"a\".charCodeAt(0);\r\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r\nrr = \"A\".charCodeAt(0);\r\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r\n\r\nfunction int2char(n) { return BI_RM.charAt(n); }\r\nfunction intAt(s,i) {\r\n  var c = BI_RC[s.charCodeAt(i)];\r\n  return (c==null)?-1:c;\r\n}\r\n\r\n// (protected) copy this to r\r\nfunction bnpCopyTo(r) {\r\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\r\n  r.t = this.t;\r\n  r.s = this.s;\r\n}\r\n\r\n// (protected) set from integer value x, -DV <= x < DV\r\nfunction bnpFromInt(x) {\r\n  this.t = 1;\r\n  this.s = (x<0)?-1:0;\r\n  if(x > 0) this[0] = x;\r\n  else if(x < -1) this[0] = x+DV;\r\n  else this.t = 0;\r\n}\r\n\r\n// return bigint initialized to value\r\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\r\n\r\n// (protected) set from string and radix\r\nfunction bnpFromString(s,b) {\r\n  var k;\r\n  if(b == 16) k = 4;\r\n  else if(b == 8) k = 3;\r\n  else if(b == 256) k = 8; // byte array\r\n  else if(b == 2) k = 1;\r\n  else if(b == 32) k = 5;\r\n  else if(b == 4) k = 2;\r\n  else { this.fromRadix(s,b); return; }\r\n  this.t = 0;\r\n  this.s = 0;\r\n  var i = s.length, mi = false, sh = 0;\r\n  while(--i >= 0) {\r\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\r\n    if(x < 0) {\r\n      if(s.charAt(i) == \"-\") mi = true;\r\n      continue;\r\n    }\r\n    mi = false;\r\n    if(sh == 0)\r\n      this[this.t++] = x;\r\n    else if(sh+k > this.DB) {\r\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\r\n      this[this.t++] = (x>>(this.DB-sh));\r\n    }\r\n    else\r\n      this[this.t-1] |= x<<sh;\r\n    sh += k;\r\n    if(sh >= this.DB) sh -= this.DB;\r\n  }\r\n  if(k == 8 && (s[0]&0x80) != 0) {\r\n    this.s = -1;\r\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\r\n  }\r\n  this.clamp();\r\n  if(mi) BigInteger.ZERO.subTo(this,this);\r\n}\r\n\r\n// (protected) clamp off excess high words\r\nfunction bnpClamp() {\r\n  var c = this.s&this.DM;\r\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\r\n}\r\n\r\n// (public) return string representation in given radix\r\nfunction bnToString(b) {\r\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\r\n  var k;\r\n  if(b == 16) k = 4;\r\n  else if(b == 8) k = 3;\r\n  else if(b == 2) k = 1;\r\n  else if(b == 32) k = 5;\r\n  else if(b == 4) k = 2;\r\n  else return this.toRadix(b);\r\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\r\n  var p = this.DB-(i*this.DB)%k;\r\n  if(i-- > 0) {\r\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\r\n    while(i >= 0) {\r\n      if(p < k) {\r\n        d = (this[i]&((1<<p)-1))<<(k-p);\r\n        d |= this[--i]>>(p+=this.DB-k);\r\n      }\r\n      else {\r\n        d = (this[i]>>(p-=k))&km;\r\n        if(p <= 0) { p += this.DB; --i; }\r\n      }\r\n      if(d > 0) m = true;\r\n      if(m) r += int2char(d);\r\n    }\r\n  }\r\n  return m?r:\"0\";\r\n}\r\n\r\n// (public) -this\r\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\r\n\r\n// (public) |this|\r\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\r\n\r\n// (public) return + if this > a, - if this < a, 0 if equal\r\nfunction bnCompareTo(a) {\r\n  var r = this.s-a.s;\r\n  if(r != 0) return r;\r\n  var i = this.t;\r\n  r = i-a.t;\r\n  if(r != 0) return (this.s<0)?-r:r;\r\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\r\n  return 0;\r\n}\r\n\r\n// returns bit length of the integer x\r\nfunction nbits(x) {\r\n  var r = 1, t;\r\n  if((t=x>>>16) != 0) { x = t; r += 16; }\r\n  if((t=x>>8) != 0) { x = t; r += 8; }\r\n  if((t=x>>4) != 0) { x = t; r += 4; }\r\n  if((t=x>>2) != 0) { x = t; r += 2; }\r\n  if((t=x>>1) != 0) { x = t; r += 1; }\r\n  return r;\r\n}\r\n\r\n// (public) return the number of bits in \"this\"\r\nfunction bnBitLength() {\r\n  if(this.t <= 0) return 0;\r\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\r\n}\r\n\r\n// (protected) r = this << n*DB\r\nfunction bnpDLShiftTo(n,r) {\r\n  var i;\r\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\r\n  for(i = n-1; i >= 0; --i) r[i] = 0;\r\n  r.t = this.t+n;\r\n  r.s = this.s;\r\n}\r\n\r\n// (protected) r = this >> n*DB\r\nfunction bnpDRShiftTo(n,r) {\r\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\r\n  r.t = Math.max(this.t-n,0);\r\n  r.s = this.s;\r\n}\r\n\r\n// (protected) r = this << n\r\nfunction bnpLShiftTo(n,r) {\r\n  var bs = n%this.DB;\r\n  var cbs = this.DB-bs;\r\n  var bm = (1<<cbs)-1;\r\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\r\n  for(i = this.t-1; i >= 0; --i) {\r\n    r[i+ds+1] = (this[i]>>cbs)|c;\r\n    c = (this[i]&bm)<<bs;\r\n  }\r\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\r\n  r[ds] = c;\r\n  r.t = this.t+ds+1;\r\n  r.s = this.s;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = this >> n\r\nfunction bnpRShiftTo(n,r) {\r\n  r.s = this.s;\r\n  var ds = Math.floor(n/this.DB);\r\n  if(ds >= this.t) { r.t = 0; return; }\r\n  var bs = n%this.DB;\r\n  var cbs = this.DB-bs;\r\n  var bm = (1<<bs)-1;\r\n  r[0] = this[ds]>>bs;\r\n  for(var i = ds+1; i < this.t; ++i) {\r\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\r\n    r[i-ds] = this[i]>>bs;\r\n  }\r\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\r\n  r.t = this.t-ds;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = this - a\r\nfunction bnpSubTo(a,r) {\r\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\r\n  while(i < m) {\r\n    c += this[i]-a[i];\r\n    r[i++] = c&this.DM;\r\n    c >>= this.DB;\r\n  }\r\n  if(a.t < this.t) {\r\n    c -= a.s;\r\n    while(i < this.t) {\r\n      c += this[i];\r\n      r[i++] = c&this.DM;\r\n      c >>= this.DB;\r\n    }\r\n    c += this.s;\r\n  }\r\n  else {\r\n    c += this.s;\r\n    while(i < a.t) {\r\n      c -= a[i];\r\n      r[i++] = c&this.DM;\r\n      c >>= this.DB;\r\n    }\r\n    c -= a.s;\r\n  }\r\n  r.s = (c<0)?-1:0;\r\n  if(c < -1) r[i++] = this.DV+c;\r\n  else if(c > 0) r[i++] = c;\r\n  r.t = i;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = this * a, r != this,a (HAC 14.12)\r\n// \"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyTo(a,r) {\r\n  var x = this.abs(), y = a.abs();\r\n  var i = x.t;\r\n  r.t = i+y.t;\r\n  while(--i >= 0) r[i] = 0;\r\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\r\n  r.s = 0;\r\n  r.clamp();\r\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\r\n}\r\n\r\n// (protected) r = this^2, r != this (HAC 14.16)\r\nfunction bnpSquareTo(r) {\r\n  var x = this.abs();\r\n  var i = r.t = 2*x.t;\r\n  while(--i >= 0) r[i] = 0;\r\n  for(i = 0; i < x.t-1; ++i) {\r\n    var c = x.am(i,x[i],r,2*i,0,1);\r\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\r\n      r[i+x.t] -= x.DV;\r\n      r[i+x.t+1] = 1;\r\n    }\r\n  }\r\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\r\n  r.s = 0;\r\n  r.clamp();\r\n}\r\n\r\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\r\n// r != q, this != m.  q or r may be null.\r\nfunction bnpDivRemTo(m,q,r) {\r\n  var pm = m.abs();\r\n  if(pm.t <= 0) return;\r\n  var pt = this.abs();\r\n  if(pt.t < pm.t) {\r\n    if(q != null) q.fromInt(0);\r\n    if(r != null) this.copyTo(r);\r\n    return;\r\n  }\r\n  if(r == null) r = nbi();\r\n  var y = nbi(), ts = this.s, ms = m.s;\r\n  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\r\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\r\n  else { pm.copyTo(y); pt.copyTo(r); }\r\n  var ys = y.t;\r\n  var y0 = y[ys-1];\r\n  if(y0 == 0) return;\r\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\r\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\r\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\r\n  y.dlShiftTo(j,t);\r\n  if(r.compareTo(t) >= 0) {\r\n    r[r.t++] = 1;\r\n    r.subTo(t,r);\r\n  }\r\n  BigInteger.ONE.dlShiftTo(ys,t);\r\n  t.subTo(y,y);\t// \"negative\" y so we can replace sub with am later\r\n  while(y.t < ys) y[y.t++] = 0;\r\n  while(--j >= 0) {\r\n    // Estimate quotient digit\r\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\r\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\r\n      y.dlShiftTo(j,t);\r\n      r.subTo(t,r);\r\n      while(r[i] < --qd) r.subTo(t,r);\r\n    }\r\n  }\r\n  if(q != null) {\r\n    r.drShiftTo(ys,q);\r\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\r\n  }\r\n  r.t = ys;\r\n  r.clamp();\r\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\r\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\r\n}\r\n\r\n// (public) this mod a\r\nfunction bnMod(a) {\r\n  var r = nbi();\r\n  this.abs().divRemTo(a,null,r);\r\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\r\n  return r;\r\n}\r\n\r\n// Modular reduction using \"classic\" algorithm\r\nfunction Classic(m) { this.m = m; }\r\nfunction cConvert(x) {\r\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\r\n  else return x;\r\n}\r\nfunction cRevert(x) { return x; }\r\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\r\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r\n\r\nClassic.prototype.convert = cConvert;\r\nClassic.prototype.revert = cRevert;\r\nClassic.prototype.reduce = cReduce;\r\nClassic.prototype.mulTo = cMulTo;\r\nClassic.prototype.sqrTo = cSqrTo;\r\n\r\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\r\n// justification:\r\n//         xy == 1 (mod m)\r\n//         xy =  1+km\r\n//   xy(2-xy) = (1+km)(1-km)\r\n// x[y(2-xy)] = 1-k^2m^2\r\n// x[y(2-xy)] == 1 (mod m^2)\r\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\r\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\r\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\r\nfunction bnpInvDigit() {\r\n  if(this.t < 1) return 0;\r\n  var x = this[0];\r\n  if((x&1) == 0) return 0;\r\n  var y = x&3;\t\t// y == 1/x mod 2^2\r\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\r\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\r\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\r\n  // last step - calculate inverse mod DV directly;\r\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\r\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\r\n  // we really want the negative inverse, and -DV < y < DV\r\n  return (y>0)?this.DV-y:-y;\r\n}\r\n\r\n// Montgomery reduction\r\nfunction Montgomery(m) {\r\n  this.m = m;\r\n  this.mp = m.invDigit();\r\n  this.mpl = this.mp&0x7fff;\r\n  this.mph = this.mp>>15;\r\n  this.um = (1<<(m.DB-15))-1;\r\n  this.mt2 = 2*m.t;\r\n}\r\n\r\n// xR mod m\r\nfunction montConvert(x) {\r\n  var r = nbi();\r\n  x.abs().dlShiftTo(this.m.t,r);\r\n  r.divRemTo(this.m,null,r);\r\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\r\n  return r;\r\n}\r\n\r\n// x/R mod m\r\nfunction montRevert(x) {\r\n  var r = nbi();\r\n  x.copyTo(r);\r\n  this.reduce(r);\r\n  return r;\r\n}\r\n\r\n// x = x/R mod m (HAC 14.32)\r\nfunction montReduce(x) {\r\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\r\n    x[x.t++] = 0;\r\n  for(var i = 0; i < this.m.t; ++i) {\r\n    // faster way of calculating u0 = x[i]*mp mod DV\r\n    var j = x[i]&0x7fff;\r\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\r\n    // use am to combine the multiply-shift-add into one call\r\n    j = i+this.m.t;\r\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\r\n    // propagate carry\r\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\r\n  }\r\n  x.clamp();\r\n  x.drShiftTo(this.m.t,x);\r\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r\n}\r\n\r\n// r = \"x^2/R mod m\"; x != r\r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r\n\r\n// r = \"xy/R mod m\"; x,y != r\r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r\n\r\nMontgomery.prototype.convert = montConvert;\r\nMontgomery.prototype.revert = montRevert;\r\nMontgomery.prototype.reduce = montReduce;\r\nMontgomery.prototype.mulTo = montMulTo;\r\nMontgomery.prototype.sqrTo = montSqrTo;\r\n\r\n// (protected) true iff this is even\r\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\r\n\r\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\r\nfunction bnpExp(e,z) {\r\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\r\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\r\n  g.copyTo(r);\r\n  while(--i >= 0) {\r\n    z.sqrTo(r,r2);\r\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\r\n    else { var t = r; r = r2; r2 = t; }\r\n  }\r\n  return z.revert(r);\r\n}\r\n\r\n// (public) this^e % m, 0 <= e < 2^32\r\nfunction bnModPowInt(e,m) {\r\n  var z;\r\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\r\n  return this.exp(e,z);\r\n}\r\n\r\n// (public)\r\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\r\n\r\n// (public) return value as integer\r\nfunction bnIntValue() {\r\n  if(this.s < 0) {\r\n    if(this.t == 1) return this[0]-this.DV;\r\n    else if(this.t == 0) return -1;\r\n  }\r\n  else if(this.t == 1) return this[0];\r\n  else if(this.t == 0) return 0;\r\n  // assumes 16 < DB < 32\r\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\r\n}\r\n\r\n// (public) return value as byte\r\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\r\n\r\n// (public) return value as short (assumes DB>=16)\r\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\r\n\r\n// (protected) return x s.t. r^x < DV\r\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\r\n\r\n// (public) 0 if this == 0, 1 if this > 0\r\nfunction bnSigNum() {\r\n  if(this.s < 0) return -1;\r\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\r\n  else return 1;\r\n}\r\n\r\n// (protected) convert to radix string\r\nfunction bnpToRadix(b) {\r\n  if(b == null) b = 10;\r\n  if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\r\n  var cs = this.chunkSize(b);\r\n  var a = Math.pow(b,cs);\r\n  var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\r\n  this.divRemTo(d,y,z);\r\n  while(y.signum() > 0) {\r\n    r = (a+z.intValue()).toString(b).substr(1) + r;\r\n    y.divRemTo(d,y,z);\r\n  }\r\n  return z.intValue().toString(b) + r;\r\n}\r\n\r\n// (protected) convert from radix string\r\nfunction bnpFromRadix(s,b) {\r\n  this.fromInt(0);\r\n  if(b == null) b = 10;\r\n  var cs = this.chunkSize(b);\r\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\r\n  for(var i = 0; i < s.length; ++i) {\r\n    var x = intAt(s,i);\r\n    if(x < 0) {\r\n      if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\r\n      continue;\r\n    }\r\n    w = b*w+x;\r\n    if(++j >= cs) {\r\n      this.dMultiply(d);\r\n      this.dAddOffset(w,0);\r\n      j = 0;\r\n      w = 0;\r\n    }\r\n  }\r\n  if(j > 0) {\r\n    this.dMultiply(Math.pow(b,j));\r\n    this.dAddOffset(w,0);\r\n  }\r\n  if(mi) BigInteger.ZERO.subTo(this,this);\r\n}\r\n\r\n// (protected) alternate constructor\r\nfunction bnpFromNumber(a,b,c) {\r\n  if(\"number\" == typeof b) {\r\n    // new BigInteger(int,int,RNG)\r\n    if(a < 2) this.fromInt(1);\r\n    else {\r\n      this.fromNumber(a,c);\r\n      if(!this.testBit(a-1))\t// force MSB set\r\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\r\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\r\n      while(!this.isProbablePrime(b)) {\r\n        this.dAddOffset(2,0);\r\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    // new BigInteger(int,RNG)\r\n    var x = new Array(), t = a&7;\r\n    x.length = (a>>3)+1;\r\n    b.nextBytes(x);\r\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\r\n    this.fromString(x,256);\r\n  }\r\n}\r\n\r\n// (public) convert to bigendian byte array\r\nfunction bnToByteArray() {\r\n  var i = this.t, r = new Array();\r\n  r[0] = this.s;\r\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\r\n  if(i-- > 0) {\r\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\r\n      r[k++] = d|(this.s<<(this.DB-p));\r\n    while(i >= 0) {\r\n      if(p < 8) {\r\n        d = (this[i]&((1<<p)-1))<<(8-p);\r\n        d |= this[--i]>>(p+=this.DB-8);\r\n      }\r\n      else {\r\n        d = (this[i]>>(p-=8))&0xff;\r\n        if(p <= 0) { p += this.DB; --i; }\r\n      }\r\n      if((d&0x80) != 0) d |= -256;\r\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\r\n      if(k > 0 || d != this.s) r[k++] = d;\r\n    }\r\n  }\r\n  return r;\r\n}\r\n\r\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\r\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\r\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\r\n\r\n// (protected) r = this op a (bitwise)\r\nfunction bnpBitwiseTo(a,op,r) {\r\n  var i, f, m = Math.min(a.t,this.t);\r\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\r\n  if(a.t < this.t) {\r\n    f = a.s&this.DM;\r\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\r\n    r.t = this.t;\r\n  }\r\n  else {\r\n    f = this.s&this.DM;\r\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\r\n    r.t = a.t;\r\n  }\r\n  r.s = op(this.s,a.s);\r\n  r.clamp();\r\n}\r\n\r\n// (public) this & a\r\nfunction op_and(x,y) { return x&y; }\r\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\r\n\r\n// (public) this | a\r\nfunction op_or(x,y) { return x|y; }\r\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\r\n\r\n// (public) this ^ a\r\nfunction op_xor(x,y) { return x^y; }\r\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\r\n\r\n// (public) this & ~a\r\nfunction op_andnot(x,y) { return x&~y; }\r\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\r\n\r\n// (public) ~this\r\nfunction bnNot() {\r\n  var r = nbi();\r\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\r\n  r.t = this.t;\r\n  r.s = ~this.s;\r\n  return r;\r\n}\r\n\r\n// (public) this << n\r\nfunction bnShiftLeft(n) {\r\n  var r = nbi();\r\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\r\n  return r;\r\n}\r\n\r\n// (public) this >> n\r\nfunction bnShiftRight(n) {\r\n  var r = nbi();\r\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\r\n  return r;\r\n}\r\n\r\n// return index of lowest 1-bit in x, x < 2^31\r\nfunction lbit(x) {\r\n  if(x == 0) return -1;\r\n  var r = 0;\r\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\r\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\r\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\r\n  if((x&3) == 0) { x >>= 2; r += 2; }\r\n  if((x&1) == 0) ++r;\r\n  return r;\r\n}\r\n\r\n// (public) returns index of lowest 1-bit (or -1 if none)\r\nfunction bnGetLowestSetBit() {\r\n  for(var i = 0; i < this.t; ++i)\r\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\r\n  if(this.s < 0) return this.t*this.DB;\r\n  return -1;\r\n}\r\n\r\n// return number of 1 bits in x\r\nfunction cbit(x) {\r\n  var r = 0;\r\n  while(x != 0) { x &= x-1; ++r; }\r\n  return r;\r\n}\r\n\r\n// (public) return number of set bits\r\nfunction bnBitCount() {\r\n  var r = 0, x = this.s&this.DM;\r\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\r\n  return r;\r\n}\r\n\r\n// (public) true iff nth bit is set\r\nfunction bnTestBit(n) {\r\n  var j = Math.floor(n/this.DB);\r\n  if(j >= this.t) return(this.s!=0);\r\n  return((this[j]&(1<<(n%this.DB)))!=0);\r\n}\r\n\r\n// (protected) this op (1<<n)\r\nfunction bnpChangeBit(n,op) {\r\n  var r = BigInteger.ONE.shiftLeft(n);\r\n  this.bitwiseTo(r,op,r);\r\n  return r;\r\n}\r\n\r\n// (public) this | (1<<n)\r\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\r\n\r\n// (public) this & ~(1<<n)\r\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\r\n\r\n// (public) this ^ (1<<n)\r\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\r\n\r\n// (protected) r = this + a\r\nfunction bnpAddTo(a,r) {\r\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\r\n  while(i < m) {\r\n    c += this[i]+a[i];\r\n    r[i++] = c&this.DM;\r\n    c >>= this.DB;\r\n  }\r\n  if(a.t < this.t) {\r\n    c += a.s;\r\n    while(i < this.t) {\r\n      c += this[i];\r\n      r[i++] = c&this.DM;\r\n      c >>= this.DB;\r\n    }\r\n    c += this.s;\r\n  }\r\n  else {\r\n    c += this.s;\r\n    while(i < a.t) {\r\n      c += a[i];\r\n      r[i++] = c&this.DM;\r\n      c >>= this.DB;\r\n    }\r\n    c += a.s;\r\n  }\r\n  r.s = (c<0)?-1:0;\r\n  if(c > 0) r[i++] = c;\r\n  else if(c < -1) r[i++] = this.DV+c;\r\n  r.t = i;\r\n  r.clamp();\r\n}\r\n\r\n// (public) this + a\r\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\r\n\r\n// (public) this - a\r\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\r\n\r\n// (public) this * a\r\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\r\n\r\n// (public) this^2\r\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\r\n\r\n// (public) this / a\r\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\r\n\r\n// (public) this % a\r\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\r\n\r\n// (public) [this/a,this%a]\r\nfunction bnDivideAndRemainder(a) {\r\n  var q = nbi(), r = nbi();\r\n  this.divRemTo(a,q,r);\r\n  return new Array(q,r);\r\n}\r\n\r\n// (protected) this *= n, this >= 0, 1 < n < DV\r\nfunction bnpDMultiply(n) {\r\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\r\n  ++this.t;\r\n  this.clamp();\r\n}\r\n\r\n// (protected) this += n << w words, this >= 0\r\nfunction bnpDAddOffset(n,w) {\r\n  if(n == 0) return;\r\n  while(this.t <= w) this[this.t++] = 0;\r\n  this[w] += n;\r\n  while(this[w] >= this.DV) {\r\n    this[w] -= this.DV;\r\n    if(++w >= this.t) this[this.t++] = 0;\r\n    ++this[w];\r\n  }\r\n}\r\n\r\n// A \"null\" reducer\r\nfunction NullExp() {}\r\nfunction nNop(x) { return x; }\r\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\r\nfunction nSqrTo(x,r) { x.squareTo(r); }\r\n\r\nNullExp.prototype.convert = nNop;\r\nNullExp.prototype.revert = nNop;\r\nNullExp.prototype.mulTo = nMulTo;\r\nNullExp.prototype.sqrTo = nSqrTo;\r\n\r\n// (public) this^e\r\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\r\n\r\n// (protected) r = lower n words of \"this * a\", a.t <= n\r\n// \"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyLowerTo(a,n,r) {\r\n  var i = Math.min(this.t+a.t,n);\r\n  r.s = 0; // assumes a,this >= 0\r\n  r.t = i;\r\n  while(i > 0) r[--i] = 0;\r\n  var j;\r\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\r\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\r\n  r.clamp();\r\n}\r\n\r\n// (protected) r = \"this * a\" without lower n words, n > 0\r\n// \"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyUpperTo(a,n,r) {\r\n  --n;\r\n  var i = r.t = this.t+a.t-n;\r\n  r.s = 0; // assumes a,this >= 0\r\n  while(--i >= 0) r[i] = 0;\r\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\r\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\r\n  r.clamp();\r\n  r.drShiftTo(1,r);\r\n}\r\n\r\n// Barrett modular reduction\r\nfunction Barrett(m) {\r\n  // setup Barrett\r\n  this.r2 = nbi();\r\n  this.q3 = nbi();\r\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\r\n  this.mu = this.r2.divide(m);\r\n  this.m = m;\r\n}\r\n\r\nfunction barrettConvert(x) {\r\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\r\n  else if(x.compareTo(this.m) < 0) return x;\r\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\r\n}\r\n\r\nfunction barrettRevert(x) { return x; }\r\n\r\n// x = x mod m (HAC 14.42)\r\nfunction barrettReduce(x) {\r\n  x.drShiftTo(this.m.t-1,this.r2);\r\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\r\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\r\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\r\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\r\n  x.subTo(this.r2,x);\r\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\r\n}\r\n\r\n// r = x^2 mod m; x != r\r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\r\n\r\n// r = x*y mod m; x,y != r\r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\r\n\r\nBarrett.prototype.convert = barrettConvert;\r\nBarrett.prototype.revert = barrettRevert;\r\nBarrett.prototype.reduce = barrettReduce;\r\nBarrett.prototype.mulTo = barrettMulTo;\r\nBarrett.prototype.sqrTo = barrettSqrTo;\r\n\r\n// (public) this^e % m (HAC 14.85)\r\nfunction bnModPow(e,m) {\r\n  var i = e.bitLength(), k, r = nbv(1), z;\r\n  if(i <= 0) return r;\r\n  else if(i < 18) k = 1;\r\n  else if(i < 48) k = 3;\r\n  else if(i < 144) k = 4;\r\n  else if(i < 768) k = 5;\r\n  else k = 6;\r\n  if(i < 8)\r\n    z = new Classic(m);\r\n  else if(m.isEven())\r\n    z = new Barrett(m);\r\n  else\r\n    z = new Montgomery(m);\r\n\r\n  // precomputation\r\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\r\n  g[1] = z.convert(this);\r\n  if(k > 1) {\r\n    var g2 = nbi();\r\n    z.sqrTo(g[1],g2);\r\n    while(n <= km) {\r\n      g[n] = nbi();\r\n      z.mulTo(g2,g[n-2],g[n]);\r\n      n += 2;\r\n    }\r\n  }\r\n\r\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\r\n  i = nbits(e[j])-1;\r\n  while(j >= 0) {\r\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\r\n    else {\r\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\r\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\r\n    }\r\n\r\n    n = k;\r\n    while((w&1) == 0) { w >>= 1; --n; }\r\n    if((i -= n) < 0) { i += this.DB; --j; }\r\n    if(is1) {\t// ret == 1, don't bother squaring or multiplying it\r\n      g[w].copyTo(r);\r\n      is1 = false;\r\n    }\r\n    else {\r\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\r\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\r\n      z.mulTo(r2,g[w],r);\r\n    }\r\n\r\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\r\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\r\n      if(--i < 0) { i = this.DB-1; --j; }\r\n    }\r\n  }\r\n  return z.revert(r);\r\n}\r\n\r\n// (public) gcd(this,a) (HAC 14.54)\r\nfunction bnGCD(a) {\r\n  var x = (this.s<0)?this.negate():this.clone();\r\n  var y = (a.s<0)?a.negate():a.clone();\r\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\r\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\r\n  if(g < 0) return x;\r\n  if(i < g) g = i;\r\n  if(g > 0) {\r\n    x.rShiftTo(g,x);\r\n    y.rShiftTo(g,y);\r\n  }\r\n  while(x.signum() > 0) {\r\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\r\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\r\n    if(x.compareTo(y) >= 0) {\r\n      x.subTo(y,x);\r\n      x.rShiftTo(1,x);\r\n    }\r\n    else {\r\n      y.subTo(x,y);\r\n      y.rShiftTo(1,y);\r\n    }\r\n  }\r\n  if(g > 0) y.lShiftTo(g,y);\r\n  return y;\r\n}\r\n\r\n// (protected) this % n, n < 2^26\r\nfunction bnpModInt(n) {\r\n  if(n <= 0) return 0;\r\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\r\n  if(this.t > 0)\r\n    if(d == 0) r = this[0]%n;\r\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\r\n  return r;\r\n}\r\n\r\n// (public) 1/this % m (HAC 14.61)\r\nfunction bnModInverse(m) {\r\n  var ac = m.isEven();\r\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\r\n  var u = m.clone(), v = this.clone();\r\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\r\n  while(u.signum() != 0) {\r\n    while(u.isEven()) {\r\n      u.rShiftTo(1,u);\r\n      if(ac) {\r\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\r\n        a.rShiftTo(1,a);\r\n      }\r\n      else if(!b.isEven()) b.subTo(m,b);\r\n      b.rShiftTo(1,b);\r\n    }\r\n    while(v.isEven()) {\r\n      v.rShiftTo(1,v);\r\n      if(ac) {\r\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\r\n        c.rShiftTo(1,c);\r\n      }\r\n      else if(!d.isEven()) d.subTo(m,d);\r\n      d.rShiftTo(1,d);\r\n    }\r\n    if(u.compareTo(v) >= 0) {\r\n      u.subTo(v,u);\r\n      if(ac) a.subTo(c,a);\r\n      b.subTo(d,b);\r\n    }\r\n    else {\r\n      v.subTo(u,v);\r\n      if(ac) c.subTo(a,c);\r\n      d.subTo(b,d);\r\n    }\r\n  }\r\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\r\n  if(d.compareTo(m) >= 0) return d.subtract(m);\r\n  if(d.signum() < 0) d.addTo(m,d); else return d;\r\n  if(d.signum() < 0) return d.add(m); else return d;\r\n}\r\n\r\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\r\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\r\n\r\n// (public) test primality with certainty >= 1-.5^t\r\nfunction bnIsProbablePrime(t) {\r\n  var i, x = this.abs();\r\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\r\n    for(i = 0; i < lowprimes.length; ++i)\r\n      if(x[0] == lowprimes[i]) return true;\r\n    return false;\r\n  }\r\n  if(x.isEven()) return false;\r\n  i = 1;\r\n  while(i < lowprimes.length) {\r\n    var m = lowprimes[i], j = i+1;\r\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\r\n    m = x.modInt(m);\r\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\r\n  }\r\n  return x.millerRabin(t);\r\n}\r\n\r\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\r\nfunction bnpMillerRabin(t) {\r\n  var n1 = this.subtract(BigInteger.ONE);\r\n  var k = n1.getLowestSetBit();\r\n  if(k <= 0) return false;\r\n  var r = n1.shiftRight(k);\r\n  t = (t+1)>>1;\r\n  if(t > lowprimes.length) t = lowprimes.length;\r\n  var a = nbi();\r\n  for(var i = 0; i < t; ++i) {\r\n    //Pick bases at random, instead of starting at 2\r\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\r\n    var y = a.modPow(r,this);\r\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\r\n      var j = 1;\r\n      while(j++ < k && y.compareTo(n1) != 0) {\r\n        y = y.modPowInt(2,this);\r\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\r\n      }\r\n      if(y.compareTo(n1) != 0) return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// protected\r\nBigInteger.prototype.chunkSize = bnpChunkSize;\r\nBigInteger.prototype.toRadix = bnpToRadix;\r\nBigInteger.prototype.fromRadix = bnpFromRadix;\r\nBigInteger.prototype.fromNumber = bnpFromNumber;\r\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\r\nBigInteger.prototype.changeBit = bnpChangeBit;\r\nBigInteger.prototype.addTo = bnpAddTo;\r\nBigInteger.prototype.dMultiply = bnpDMultiply;\r\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\r\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\r\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\r\nBigInteger.prototype.modInt = bnpModInt;\r\nBigInteger.prototype.millerRabin = bnpMillerRabin;\r\n\r\n// public\r\nBigInteger.prototype.clone = bnClone;\r\nBigInteger.prototype.intValue = bnIntValue;\r\nBigInteger.prototype.byteValue = bnByteValue;\r\nBigInteger.prototype.shortValue = bnShortValue;\r\nBigInteger.prototype.signum = bnSigNum;\r\nBigInteger.prototype.toByteArray = bnToByteArray;\r\nBigInteger.prototype.equals = bnEquals;\r\nBigInteger.prototype.min = bnMin;\r\nBigInteger.prototype.max = bnMax;\r\nBigInteger.prototype.and = bnAnd;\r\nBigInteger.prototype.or = bnOr;\r\nBigInteger.prototype.xor = bnXor;\r\nBigInteger.prototype.andNot = bnAndNot;\r\nBigInteger.prototype.not = bnNot;\r\nBigInteger.prototype.shiftLeft = bnShiftLeft;\r\nBigInteger.prototype.shiftRight = bnShiftRight;\r\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\r\nBigInteger.prototype.bitCount = bnBitCount;\r\nBigInteger.prototype.testBit = bnTestBit;\r\nBigInteger.prototype.setBit = bnSetBit;\r\nBigInteger.prototype.clearBit = bnClearBit;\r\nBigInteger.prototype.flipBit = bnFlipBit;\r\nBigInteger.prototype.add = bnAdd;\r\nBigInteger.prototype.subtract = bnSubtract;\r\nBigInteger.prototype.multiply = bnMultiply;\r\nBigInteger.prototype.divide = bnDivide;\r\nBigInteger.prototype.remainder = bnRemainder;\r\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\r\nBigInteger.prototype.modPow = bnModPow;\r\nBigInteger.prototype.modInverse = bnModInverse;\r\nBigInteger.prototype.pow = bnPow;\r\nBigInteger.prototype.gcd = bnGCD;\r\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\r\n\r\n// JSBN-specific extension\r\nBigInteger.prototype.square = bnSquare;\r\n\r\n// BigInteger interfaces not implemented in jsbn:\r\n\r\n// BigInteger(int signum, byte[] magnitude)\r\n// double doubleValue()\r\n// float floatValue()\r\n// int hashCode()\r\n// long longValue()\r\n// static BigInteger valueOf(long val)\r\n// protected\r\nBigInteger.prototype.copyTo = bnpCopyTo;\r\nBigInteger.prototype.fromInt = bnpFromInt;\r\nBigInteger.prototype.fromString = bnpFromString;\r\nBigInteger.prototype.clamp = bnpClamp;\r\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\r\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\r\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\r\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\r\nBigInteger.prototype.subTo = bnpSubTo;\r\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\r\nBigInteger.prototype.squareTo = bnpSquareTo;\r\nBigInteger.prototype.divRemTo = bnpDivRemTo;\r\nBigInteger.prototype.invDigit = bnpInvDigit;\r\nBigInteger.prototype.isEven = bnpIsEven;\r\nBigInteger.prototype.exp = bnpExp;\r\n\r\n// public\r\nBigInteger.prototype.toString = bnToString;\r\nBigInteger.prototype.negate = bnNegate;\r\nBigInteger.prototype.abs = bnAbs;\r\nBigInteger.prototype.compareTo = bnCompareTo;\r\nBigInteger.prototype.bitLength = bnBitLength;\r\nBigInteger.prototype.mod = bnMod;\r\nBigInteger.prototype.modPowInt = bnModPowInt;\r\n\r\n// \"constants\"\r\nBigInteger.ZERO = nbv(0);\r\nBigInteger.ONE = nbv(1);\r\n\r\nexports.nbi\t    = nbi;\r\nexports.BigInteger  = BigInteger;\r\n\r\n// vim:sw=2:sts=2:ts=8:et\r\n\n\n// WEBPACK FOOTER //\n// module.id = 9\n// module.realId = 6\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/jsbn.js");

/******/},
/******/
/******/7: function(module, exports, require) {

/******/ /* WEBPACK FREE VAR INJECTION */ (function(console) {
eval("// Remote access to a server.\r\n// - We never send binary data.\r\n// - We use the W3C interface for node and browser compatibility:\r\n//   http://www.w3.org/TR/websockets/#the-websocket-interface\r\n//\r\n// This class is intended for both browser and node.js use.\r\n//\r\n// This class is designed to work via peer protocol via either the public or\r\n// private websocket interfaces.  The JavaScript class for the peer protocol\r\n// has not yet been implemented. However, this class has been designed for it\r\n// to be a very simple drop option.\r\n//\r\n// YYY Will later provide js/network.js which will transparently use multiple\r\n// instances of this class for network access.\r\n//\r\n\r\n// npm\r\nvar WebSocket     = require(9);\r\n\r\nvar EventEmitter  = require(5).EventEmitter;\r\nvar Amount        = require(2).Amount;\r\nvar Currency      = require(2).Currency;\r\nvar UInt160       = require(2).UInt160;\r\n\r\nvar utils         = require(8);\r\n\r\n// Request events emitted:\r\n// 'success' : Request successful.\r\n// 'error'   : Request failed.\r\n//   'remoteError'\r\n//   'remoteUnexpected'\r\n//   'remoteDisconnected'\r\nvar Request = function (remote, command) {\r\n  var self  = this;\r\n\r\n  this.message    = {\r\n    'command' : command,\r\n    'id'      : undefined,\r\n  };\r\n  this.remote     = remote;\r\n  this.requested  = false;\r\n};\r\n\r\nRequest.prototype  = new EventEmitter;\r\n\r\n// Send the request to a remote.\r\nRequest.prototype.request = function (remote) {\r\n  if (!this.requested) {\r\n    this.requested  = true;\r\n    this.remote.request(this);\r\n    this.emit('request', remote);\r\n  }\r\n};\r\n\r\nRequest.prototype.build_path = function (build) {\r\n  if (build)\r\n    this.message.build_path = true;\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.ledger_choose = function (current) {\r\n  if (current)\r\n  {\r\n    this.message.ledger_index = this.remote._ledger_current_index;\r\n  }\r\n  else {\r\n    this.message.ledger_hash  = this.remote._ledger_hash;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Set the ledger for a request.\r\n// - ledger_entry\r\n// - transaction_entry\r\nRequest.prototype.ledger_hash = function (h) {\r\n  this.message.ledger_hash  = h;\r\n\r\n  return this;\r\n};\r\n\r\n// Set the ledger_index for a request.\r\n// - ledger_entry\r\nRequest.prototype.ledger_index = function (ledger_index) {\r\n  this.message.ledger_index  = ledger_index;\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.account_root = function (account) {\r\n  this.message.account_root  = UInt160.json_rewrite(account);\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.index = function (hash) {\r\n  this.message.index  = hash;\r\n\r\n  return this;\r\n};\r\n\r\n// Provide the information id an offer.\r\n// --> account\r\n// --> seq : sequence number of transaction creating offer (integer)\r\nRequest.prototype.offer_id = function (account, seq) {\r\n  this.message.offer = {\r\n    'account' : UInt160.json_rewrite(account),\r\n    'seq' : seq\r\n  };\r\n\r\n  return this;\r\n};\r\n\r\n// --> index : ledger entry index.\r\nRequest.prototype.offer_index = function (index) {\r\n  this.message.offer  = index;\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.secret = function (s) {\r\n  if (s)\r\n    this.message.secret  = s;\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.tx_hash = function (h) {\r\n  this.message.tx_hash  = h;\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.tx_json = function (j) {\r\n  this.message.tx_json  = j;\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.ripple_state = function (account, issuer, currency) {\r\n  this.message.ripple_state  = {\r\n      'accounts' : [\r\n        UInt160.json_rewrite(account),\r\n        UInt160.json_rewrite(issuer)\r\n      ],\r\n      'currency' : currency\r\n    };\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.accounts = function (accounts, realtime) {\r\n  if (\"object\" !== typeof accounts) {\r\n    accounts = [accounts];\r\n  }\r\n\r\n  // Process accounts parameters\r\n  var procAccounts = [];\r\n  for (var i = 0, l = accounts.length; i < l; i++) {\r\n    procAccounts.push(UInt160.json_rewrite(accounts[i]));\r\n  }\r\n  if (realtime) {\r\n    this.message.rt_accounts = procAccounts;\r\n  } else {\r\n    this.message.accounts = procAccounts;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nRequest.prototype.rt_accounts = function (accounts) {\r\n  return this.accounts(accounts, true);\r\n};\r\n\r\n//\r\n// Remote - access to a remote Ripple server via websocket.\r\n//\r\n// Events:\r\n// 'connected'\r\n// 'disconnected'\r\n// 'state':\r\n// - 'online' : connected and subscribed\r\n// - 'offline' : not subscribed or not connected.\r\n// 'ledger_closed': A good indicate of ready to serve.\r\n// 'subscribed' : This indicates stand-alone is available.\r\n//\r\n\r\n// --> trusted: truthy, if remote is trusted\r\nvar Remote = function (opts, trace) {\r\n  this.trusted                = opts.trusted;\r\n  this.websocket_ip           = opts.websocket_ip;\r\n  this.websocket_port         = opts.websocket_port;\r\n  this.websocket_ssl          = opts.websocket_ssl;\r\n  this.local_sequence         = opts.local_sequence; // Locally track sequence numbers\r\n  this.local_fee              = opts.local_fee;      // Locally set fees\r\n  this.id                     = 0;\r\n  this.trace                  = opts.trace || trace;\r\n  this._ledger_current_index  = undefined;\r\n  this._ledger_hash           = undefined;\r\n  this._ledger_time           = undefined;\r\n  this.stand_alone            = undefined;\r\n  this.online_target          = false;\r\n  this.online_state           = 'closed';         // 'open', 'closed', 'connecting', 'closing'\r\n  this.state                  = 'offline';        // 'online', 'offline'\r\n  this.retry_timer            = undefined;\r\n  this.retry                  = undefined;\r\n\r\n  // Cache information for accounts.\r\n  this.accounts = {\r\n    // Consider sequence numbers stable if you know you're not generating bad transactions.\r\n    // Otherwise, clear it to have it automatically refreshed from the network.\r\n\r\n    // account : { seq : __ }\r\n\r\n    };\r\n\r\n  // List of secrets that we know about.\r\n  this.secrets = {\r\n    // Secrets can be set by calling set_secret(account, secret).\r\n\r\n    // account : secret\r\n  };\r\n\r\n  // Cache for various ledgers.\r\n  // XXX Clear when ledger advances.\r\n  this.ledgers = {\r\n    'current' : {\r\n      'account_root' : {}\r\n    }\r\n  };\r\n};\r\n\r\nRemote.prototype      = new EventEmitter;\r\n\r\nRemote.from_config = function (obj, trace) {\r\n  var serverConfig = 'string' === typeof obj ? exports.config.servers[obj] : obj;\r\n\r\n  var remote = new Remote(serverConfig, trace);\r\n\r\n  for (var account in exports.config.accounts) {\r\n    var accountInfo = exports.config.accounts[account];\r\n    if (\"object\" === typeof accountInfo) {\r\n      if (accountInfo.secret) {\r\n        // Index by nickname ...\r\n        remote.set_secret(account, accountInfo.secret);\r\n        // ... and by account ID\r\n        remote.set_secret(accountInfo.account, accountInfo.secret);\r\n      }\r\n    }\r\n  }\r\n\r\n  return remote;\r\n};\r\n\r\nvar isTemMalformed  = function (engine_result_code) {\r\n  return (engine_result_code >= -299 && engine_result_code <  199);\r\n};\r\n\r\nvar isTefFailure = function (engine_result_code) {\r\n  return (engine_result_code >= -299 && engine_result_code <  199);\r\n};\r\n\r\nRemote.flags = {\r\n  'OfferCreate' : {\r\n    'Passive'                 : 0x00010000,\r\n  },\r\n\r\n  'Payment' : {\r\n    'CreateAccount'           : 0x00010000,\r\n    'PartialPayment'          : 0x00020000,\r\n    'LimitQuality'            : 0x00040000,\r\n    'NoRippleDirect'          : 0x00080000,\r\n  },\r\n};\r\n\r\n// XXX This needs to be determined from the network.\r\nRemote.fees = {\r\n  'default'         : Amount.from_json(\"10\"),\r\n  'account_create'  : Amount.from_json(\"1000000000\"),\r\n  'nickname_create' : Amount.from_json(\"1000\"),\r\n  'offer'           : Amount.from_json(\"10\"),\r\n};\r\n\r\n// Set the emitted state: 'online' or 'offline'\r\nRemote.prototype._set_state = function (state) {\r\n  if (this.trace) console.log(\"remote: set_state: %s\", state);\r\n\r\n  if (this.state !== state) {\r\n    this.state = state;\r\n\r\n    this.emit('state', state);\r\n    switch (state) {\r\n      case 'online':\r\n        this.online_state       = 'open';\r\n        this.emit('connected');\r\n        break;\r\n\r\n      case 'offline':\r\n        this.online_state       = 'closed';\r\n        this.emit('disconnected');\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\nRemote.prototype.set_trace = function (trace) {\r\n  this.trace  = undefined === trace || trace;\r\n\r\n  return this;\r\n};\r\n\r\n// Set the target online state. Defaults to false.\r\nRemote.prototype.connect = function (online) {\r\n  var target  = undefined === online || online;\r\n\r\n  if (this.online_target != target) {\r\n    this.online_target  = target;\r\n\r\n    // If we were in a stable state, go dynamic.\r\n    switch (this.online_state) {\r\n      case 'open':\r\n        if (!target) this._connect_stop();\r\n        break;\r\n\r\n      case 'closed':\r\n        if (target) this._connect_retry();\r\n        break;\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nRemote.prototype.ledger_hash = function () {\r\n  return this._ledger_hash;\r\n};\r\n\r\n// Stop from open state.\r\nRemote.prototype._connect_stop = function () {\r\n  delete this.ws.onerror;\r\n  delete this.ws.onclose;\r\n\r\n  this.ws.terminate();\r\n  delete this.ws;\r\n\r\n  this._set_state('offline');\r\n};\r\n\r\n// Implictly we are not connected.\r\nRemote.prototype._connect_retry = function () {\r\n  var self  = this;\r\n\r\n  if (!self.online_target) {\r\n    // Do not continue trying to connect.\r\n    this._set_state('offline');\r\n  }\r\n  else if ('connecting' !== this.online_state) {\r\n    // New to connecting state.\r\n    this.online_state = 'connecting';\r\n    this.retry        = 0;\r\n\r\n    this._set_state('offline'); // Report newly offline.\r\n    this._connect_start();\r\n  }\r\n  else\r\n  {\r\n    // Delay and retry.\r\n    this.retry        += 1;\r\n    this.retry_timer  =  setTimeout(function () {\r\n        if (self.trace) console.log(\"remote: retry\");\r\n\r\n        if (self.online_target) {\r\n          self._connect_start();\r\n        }\r\n        else {\r\n          self._connect_retry();\r\n        }\r\n      }, this.retry < 40 ? 1000/20 : 1000); // 20 times per second for 2 seconds then once per second.\r\n  }\r\n};\r\n\r\nRemote.prototype._connect_start = function () {\r\n  // Note: as a browser client can't make encrypted connections to random ips\r\n  // with self-signed certs as the user must have pre-approved the self-signed certs.\r\n\r\n  var self = this;\r\n  var url  = (this.websocket_ssl ? \"wss://\" : \"ws://\") +\r\n        this.websocket_ip + \":\" + this.websocket_port;\r\n\r\n  if (this.trace) console.log(\"remote: connect: %s\", url);\r\n\r\n  var ws = this.ws = new WebSocket(url);\r\n\r\n  ws.response = {};\r\n\r\n  ws.onopen = function () {\r\n    if (self.trace) console.log(\"remote: onopen: %s: online_target=%s\", ws.readyState, self.online_target);\r\n\r\n    ws.onerror = function () {\r\n      if (self.trace) console.log(\"remote: onerror: %s\", ws.readyState);\r\n\r\n      delete ws.onclose;\r\n\r\n      self._connect_retry();\r\n    };\r\n\r\n    ws.onclose = function () {\r\n      if (self.trace) console.log(\"remote: onclose: %s\", ws.readyState);\r\n\r\n      delete ws.onerror;\r\n\r\n      self._connect_retry();\r\n    };\r\n\r\n    if (self.online_target) {\r\n      // Note, we could get disconnected before this goes through.\r\n      self._server_subscribe();     // Automatically subscribe.\r\n    }\r\n    else {\r\n      self._connect_stop();\r\n    }\r\n  };\r\n\r\n  ws.onerror = function () {\r\n    if (self.trace) console.log(\"remote: onerror: %s\", ws.readyState);\r\n\r\n    delete ws.onclose;\r\n\r\n    self._connect_retry();\r\n  };\r\n\r\n  // Failure to open.\r\n  ws.onclose = function () {\r\n    if (self.trace) console.log(\"remote: onclose: %s\", ws.readyState);\r\n\r\n    delete ws.onerror;\r\n\r\n    self._connect_retry();\r\n  };\r\n\r\n  ws.onmessage = function (json) {\r\n    self._connect_message(ws, json.data);\r\n  };\r\n};\r\n\r\n// It is possible for messages to be dispatched after the connection is closed.\r\nRemote.prototype._connect_message = function (ws, json) {\r\n  var message     = JSON.parse(json);\r\n  var unexpected  = false;\r\n  var request;\r\n\r\n  if ('object' !== typeof message) {\r\n    unexpected  = true;\r\n  }\r\n  else {\r\n    switch (message.type) {\r\n      case 'response':\r\n        // A response to a request.\r\n        {\r\n          request         = ws.response[message.id];\r\n\r\n          if (!request) {\r\n            unexpected  = true;\r\n          }\r\n          else if ('success' === message.status) {\r\n            if (this.trace) utils.logObject(\"remote: response: %s\", message);\r\n\r\n            request.emit('success', message.result);\r\n          }\r\n          else if (message.error) {\r\n            if (this.trace) utils.logObject(\"remote: error: %s\", message);\r\n\r\n            request.emit('error', {\r\n                'error'         : 'remoteError',\r\n                'error_message' : 'Remote reported an error.',\r\n                'remote'        : message,\r\n              });\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'ledgerClosed':\r\n        // XXX If not trusted, need to verify we consider ledger closed.\r\n        // XXX Also need to consider a slow server or out of order response.\r\n        // XXX Be more defensive fields could be missing or of wrong type.\r\n        // YYY Might want to do some cache management.\r\n\r\n        this._ledger_time           = message.ledger_time;\r\n        this._ledger_hash           = message.ledger_hash;\r\n        this._ledger_current_index  = message.ledger_index + 1;\r\n\r\n        this.emit('ledger_closed', message);\r\n        break;\r\n\r\n      case 'serverStatus':\r\n        this._set_state(message.server_status === 'ok' ? 'online' : 'offline');\r\n        break;\r\n\r\n      // All other messages\r\n      default:\r\n        if (this.trace) utils.logObject(\"remote: \"+message.type+\": %s\", message);\r\n        this.emit('net_'+message.type, message);\r\n        break;\r\n    }\r\n  }\r\n\r\n  if (!unexpected) {\r\n  }\r\n  // Unexpected response from remote.\r\n  // XXX This isn't so robust. Hard fails should probably only happen in a debugging scenairo.\r\n  else if (this.trusted) {\r\n    // Remote is trusted, report an error.\r\n    console.log(\"unexpected message from trusted remote: %s\", json);\r\n\r\n    (request || this).emit('error', {\r\n        'error' : 'remoteUnexpected',\r\n        'error_message' : 'Unexpected response from remote.'\r\n      });\r\n  }\r\n  else {\r\n    // Treat as a disconnect.\r\n    if (this.trace) console.log(\"unexpected message from untrusted remote: %s\", json);\r\n\r\n    // XXX All pending request need this treatment and need to actionally disconnect.\r\n    (request || this).emit('error', {\r\n        'error' : 'remoteDisconnected',\r\n        'error_message' : 'Remote disconnected.'\r\n      });\r\n  }\r\n};\r\n\r\n// Send a request.\r\n// <-> request: what to send, consumed.\r\nRemote.prototype.request = function (request) {\r\n  if (this.ws) {\r\n    // Only bother if we are still connected.\r\n\r\n    this.ws.response[request.message.id = this.id] = request;\r\n\r\n    this.id += 1;   // Advance id.\r\n\r\n    if (this.trace) utils.logObject(\"remote: request: %s\", request.message);\r\n\r\n    this.ws.send(JSON.stringify(request.message));\r\n  }\r\n  else {\r\n    if (this.trace) utils.logObject(\"remote: request: DROPPING: %s\", request.message);\r\n  }\r\n};\r\n\r\nRemote.prototype.request_server_info = function () {\r\n  return new Request(this, 'server_info');\r\n};\r\n\r\n// XXX This is a bad command. Some varients don't scale.\r\n// XXX Require the server to be trusted.\r\nRemote.prototype.request_ledger = function (ledger, full) {\r\n  //utils.assert(this.trusted);\r\n\r\n  var request = new Request(this, 'ledger');\r\n\r\n  if (ledger)\r\n    request.message.ledger  = ledger;\r\n\r\n  if (full)\r\n    request.message.full    = true;\r\n\r\n  return request;\r\n};\r\n\r\n// Only for unit testing.\r\nRemote.prototype.request_ledger_hash = function () {\r\n  //utils.assert(this.trusted);   // If not trusted, need to check proof.\r\n\r\n  return new Request(this, 'ledger_closed');\r\n};\r\n\r\n// .ledger()\r\n// .ledger_index()\r\nRemote.prototype.request_ledger_header = function () {\r\n  return new Request(this, 'ledger_header');\r\n};\r\n\r\n// Get the current proposed ledger entry.  May be closed (and revised) at any time (even before returning).\r\n// Only for unit testing.\r\nRemote.prototype.request_ledger_current = function () {\r\n  return new Request(this, 'ledger_current');\r\n};\r\n\r\n// --> type : the type of ledger entry.\r\n// .ledger()\r\n// .ledger_index()\r\n// .offer_id()\r\nRemote.prototype.request_ledger_entry = function (type) {\r\n  //utils.assert(this.trusted);   // If not trusted, need to check proof, maybe talk packet protocol.\r\n\r\n  var self    = this;\r\n  var request = new Request(this, 'ledger_entry');\r\n\r\n  // Transparent caching. When .request() is invoked, look in the Remote object for the result.\r\n  // If not found, listen, cache result, and emit it.\r\n  //\r\n  // Transparent caching:\r\n  if ('account_root' === type) {\r\n    request.request_default = request.request;\r\n\r\n    request.request         = function () {                        // Intercept default request.\r\n      var bDefault  = true;\r\n      // .self = Remote\r\n      // this = Request\r\n\r\n      // console.log('request_ledger_entry: caught');\r\n\r\n\r\n      if (self._ledger_hash) {\r\n        // A specific ledger is requested.\r\n\r\n        // XXX Add caching.\r\n      }\r\n      // else if (req.ledger_index)\r\n      // else if ('ripple_state' === request.type)         // YYY Could be cached per ledger.\r\n      else if ('account_root' === type) {\r\n        var cache = self.ledgers.current.account_root;\r\n\r\n        if (!cache)\r\n        {\r\n          cache = self.ledgers.current.account_root = {};\r\n        }\r\n\r\n        var node = self.ledgers.current.account_root[request.message.account_root];\r\n\r\n        if (node) {\r\n          // Emulate fetch of ledger entry.\r\n          // console.log('request_ledger_entry: emulating');\r\n          request.emit('success', {\r\n              // YYY Missing lots of fields.\r\n              'node' :  node,\r\n            });\r\n\r\n          bDefault  = false;\r\n        }\r\n        else {\r\n          // Was not cached.\r\n\r\n          // XXX Only allow with trusted mode.  Must sync response with advance.\r\n          switch (type) {\r\n            case 'account_root':\r\n              request.on('success', function (message) {\r\n                  // Cache node.\r\n                  // console.log('request_ledger_entry: caching');\r\n                  self.ledgers.current.account_root[message.node.Account] = message.node;\r\n                });\r\n              break;\r\n\r\n            default:\r\n              // This type not cached.\r\n              // console.log('request_ledger_entry: non-cached type');\r\n          }\r\n        }\r\n      }\r\n\r\n      if (bDefault) {\r\n        // console.log('request_ledger_entry: invoking');\r\n        request.request_default();\r\n      }\r\n    }\r\n  };\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.request_subscribe = function (streams) {\r\n  var request = new Request(this, 'subscribe');\r\n\r\n  if (streams) {\r\n    if (\"object\" !== typeof streams) {\r\n      streams = [streams];\r\n    }\r\n    request.message.streams = streams;\r\n  }\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.request_unsubscribe = function (streams) {\r\n  var request = new Request(this, 'unsubscribe');\r\n\r\n  if (streams) {\r\n    if (\"object\" !== typeof streams) {\r\n      streams = [streams];\r\n    }\r\n    request.message.streams = streams;\r\n  }\r\n\r\n  return request;\r\n};\r\n\r\n// --> current: true, for the current ledger.\r\nRemote.prototype.request_transaction_entry = function (hash, current) {\r\n  //utils.assert(this.trusted);   // If not trusted, need to check proof, maybe talk packet protocol.\r\n\r\n  return (new Request(this, 'transaction_entry'))\r\n    .ledger_choose(current)\r\n    .tx_hash(hash);\r\n};\r\n\r\n// --> account_index: sub_account index (optional)\r\n// --> current: true, for the current ledger.\r\nRemote.prototype.request_account_lines = function (accountID, account_index, current) {\r\n  // XXX Does this require the server to be trusted?\r\n  //utils.assert(this.trusted);\r\n\r\n  var request = new Request(this, 'account_lines');\r\n\r\n  request.message.account = UInt160.json_rewrite(accountID);\r\n\r\n  if (account_index)\r\n    request.message.index   = account_index;\r\n\r\n  return request\r\n    .ledger_choose(current);\r\n};\r\n\r\n// --> account_index: sub_account index (optional)\r\n// --> current: true, for the current ledger.\r\nRemote.prototype.request_account_offers = function (accountID, account_index, current) {\r\n  var request = new Request(this, 'account_offers');\r\n\r\n  request.message.account = UInt160.json_rewrite(accountID);\r\n\r\n  if (account_index)\r\n    request.message.index   = account_index;\r\n\r\n  return request\r\n    .ledger_choose(current);\r\n};\r\n\r\nRemote.prototype.request_account_tx = function (accountID, ledger_min, ledger_max) {\r\n  // XXX Does this require the server to be trusted?\r\n  //utils.assert(this.trusted);\r\n\r\n  var request = new Request(this, 'account_tx');\r\n\r\n  request.message.account     = accountID;\r\n\r\n  if (ledger_min === ledger_max) {\r\n    request.message.ledger      = ledger_min;\r\n  }\r\n  else {\r\n    request.message.ledger_min  = ledger_min;\r\n    request.message.ledger_max  = ledger_max;\r\n  }\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.request_ledger = function (ledger, full) {\r\n  var request = new Request(this, 'ledger');\r\n\r\n  request.message.ledger = ledger;\r\n\r\n  if (full)\r\n    request.message.full = true;\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.request_wallet_accounts = function (seed) {\r\n  utils.assert(this.trusted);     // Don't send secrets.\r\n\r\n  var request = new Request(this, 'wallet_accounts');\r\n\r\n  request.message.seed = seed;\r\n\r\n  return request;\r\n};\r\n\r\n// Submit a transaction.\r\nRemote.prototype.submit = function (transaction) {\r\n  var self  = this;\r\n\r\n  if (transaction._secret && !this.trusted)\r\n  {\r\n    transaction.emit('error', {\r\n        'result'          : 'tejServerUntrusted',\r\n        'result_message'  : \"Attempt to give a secret to an untrusted server.\"\r\n      });\r\n  }\r\n  else {\r\n    if (self.local_sequence && !transaction.tx_json.Sequence) {\r\n      transaction.tx_json.Sequence      = this.account_seq(transaction.tx_json.Account, 'ADVANCE');\r\n      // console.log(\"Sequence: %s\", transaction.tx_json.Sequence);\r\n    }\r\n\r\n    if (self.local_sequence && !transaction.tx_json.Sequence) {\r\n      // Look in the last closed ledger.\r\n      this.account_seq_cache(transaction.tx_json.Account, false)\r\n        .on('success_account_seq_cache', function () {\r\n            // Try again.\r\n            self.submit(transaction);\r\n          })\r\n        .on('error_account_seq_cache', function (message) {\r\n            // XXX Maybe be smarter about this. Don't want to trust an untrusted server for this seq number.\r\n\r\n            // Look in the current ledger.\r\n            self.account_seq_cache(transaction.tx_json.Account, 'CURRENT')\r\n              .on('success_account_seq_cache', function () {\r\n                  // Try again.\r\n                  self.submit(transaction);\r\n                })\r\n              .on('error_account_seq_cache', function (message) {\r\n                  // Forward errors.\r\n                  transaction.emit('error', message);\r\n                })\r\n              .request();\r\n          })\r\n        .request();\r\n    }\r\n    else {\r\n      // Convert the transaction into a request and submit it.\r\n\r\n      (new Request(this, 'submit'))\r\n        .build_path(transaction._build_path)\r\n        .tx_json(transaction.tx_json)\r\n        .secret(transaction._secret)\r\n        .on('success', function (message) { transaction.emit('success', message); }) // Forward successes and errors.\r\n        .on('error', function (message) { transaction.emit('error', message); })\r\n        .request();\r\n    }\r\n  }\r\n};\r\n\r\n//\r\n// Higher level functions.\r\n//\r\n\r\n// Subscribe to a server to get 'ledger_closed' events.\r\n// 'subscribed' : This command was successful.\r\n// 'ledger_closed : ledger_closed and ledger_current_index are updated.\r\nRemote.prototype._server_subscribe = function () {\r\n  var self  = this;\r\n\r\n  this.request_subscribe([ 'ledger', 'server' ])\r\n    .on('success', function (message) {\r\n        self.stand_alone          = !!message.stand_alone;\r\n\r\n        if (message.random)\r\n          self.emit('random', utils.hexToArray(message.random));\r\n\r\n        if (message.ledger_hash && message.ledger_index) {\r\n          self._ledger_time           = message.ledger_time;\r\n          self._ledger_hash           = message.ledger_hash;\r\n          self._ledger_current_index  = message.ledger_index+1;\r\n\r\n          self.emit('ledger_closed', message);\r\n        }\r\n\r\n        if (message.server_status === \"ok\") {\r\n          self._set_state('online');\r\n        }\r\n\r\n        self.emit('subscribed');\r\n      })\r\n    .request();\r\n\r\n  // XXX Could give error events, maybe even time out.\r\n\r\n  return this;\r\n};\r\n\r\n// For unit testing: ask the remote to accept the current ledger.\r\n// - To be notified when the ledger is accepted, server_subscribe() then listen to 'ledger_hash' events.\r\n// A good way to be notified of the result of this is:\r\n//    remote.once('ledger_closed', function (ledger_closed, ledger_index) { ... } );\r\nRemote.prototype.ledger_accept = function () {\r\n  if (this.stand_alone || undefined === this.stand_alone)\r\n  {\r\n    var request = new Request(this, 'ledger_accept');\r\n\r\n    request\r\n      .request();\r\n  }\r\n  else {\r\n    this.emit('error', {\r\n        'error' : 'notStandAlone'\r\n      });\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// Return a request to refresh the account balance.\r\nRemote.prototype.request_account_balance = function (account, current) {\r\n  var request = this.request_ledger_entry('account_root');\r\n\r\n  return request\r\n    .account_root(account)\r\n    .ledger_choose(current)\r\n    .on('success', function (message) {\r\n        // If the caller also waits for 'success', they might run before this.\r\n        request.emit('account_balance', Amount.from_json(message.node.Balance));\r\n      });\r\n};\r\n\r\n// Return the next account sequence if possible.\r\n// <-- undefined or Sequence\r\nRemote.prototype.account_seq = function (account, advance) {\r\n  var account       = UInt160.json_rewrite(account);\r\n  var account_info  = this.accounts[account];\r\n  var seq;\r\n\r\n  if (account_info && account_info.seq)\r\n  {\r\n    seq = account_info.seq;\r\n\r\n    if (advance) account_info.seq += 1;\r\n\r\n    // console.log(\"cached: %s current=%d next=%d\", account, seq, account_info.seq);\r\n  }\r\n  else {\r\n    // console.log(\"uncached: %s\", account);\r\n  }\r\n\r\n  return seq;\r\n}\r\n\r\nRemote.prototype.set_account_seq = function (account, seq) {\r\n  var account       = UInt160.json_rewrite(account);\r\n\r\n  if (!this.accounts[account]) this.accounts[account] = {};\r\n\r\n  this.accounts[account].seq = seq;\r\n}\r\n\r\n// Return a request to refresh accounts[account].seq.\r\nRemote.prototype.account_seq_cache = function (account, current) {\r\n  var self    = this;\r\n  var request;\r\n\r\n  if (!self.accounts[account]) self.accounts[account] = {};\r\n\r\n  var account_info = self.accounts[account];\r\n\r\n  request = account_info.caching_seq_request;\r\n  if (!request) {\r\n    // console.log(\"starting: %s\", account);\r\n    request = self.request_ledger_entry('account_root')\r\n      .account_root(account)\r\n      .ledger_choose(current)\r\n      .on('success', function (message) {\r\n          delete account_info.caching_seq_request;\r\n\r\n          var seq = message.node.Sequence;\r\n\r\n          account_info.seq  = seq;\r\n\r\n          // console.log(\"caching: %s %d\", account, seq);\r\n          // If the caller also waits for 'success', they might run before this.\r\n          request.emit('success_account_seq_cache', message);\r\n        })\r\n      .on('error', function (message) {\r\n          // console.log(\"error: %s\", account);\r\n          delete account_info.caching_seq_request;\r\n\r\n          request.emit('error_account_seq_cache', message);\r\n        });\r\n\r\n    account_info.caching_seq_request    = request;\r\n  }\r\n\r\n  return request;\r\n};\r\n\r\n// Mark an account's root node as dirty.\r\nRemote.prototype.dirty_account_root = function (account) {\r\n  var account       = UInt160.json_rewrite(account);\r\n\r\n  delete this.ledgers.current.account_root[account];\r\n};\r\n\r\n// Store a secret - allows the Remote to automatically fill out auth information.\r\nRemote.prototype.set_secret = function (account, secret) {\r\n  this.secrets[account] = secret;\r\n};\r\n\r\n\r\n// Return a request to get a ripple balance.\r\n//\r\n// --> account: String\r\n// --> issuer: String\r\n// --> currency: String\r\n// --> current: bool : true = current ledger\r\n//\r\n// If does not exist: emit('error', 'error' : 'remoteError', 'remote' : { 'error' : 'entryNotFound' })\r\nRemote.prototype.request_ripple_balance = function (account, issuer, currency, current) {\r\n  var request       = this.request_ledger_entry('ripple_state');          // YYY Could be cached per ledger.\r\n\r\n  return request\r\n    .ripple_state(account, issuer, currency)\r\n    .ledger_choose(current)\r\n    .on('success', function (message) {\r\n        var node            = message.node;\r\n\r\n        var lowLimit        = Amount.from_json(node.LowLimit);\r\n        var highLimit       = Amount.from_json(node.HighLimit);\r\n        // The amount the low account holds of issuer.\r\n        var balance         = Amount.from_json(node.Balance);\r\n        // accountHigh implies: for account: balance is negated, highLimit is the limit set by account.\r\n        var accountHigh     = UInt160.from_json(account).equals(highLimit.issuer());\r\n        // The limit set by account.\r\n        var accountLimit    = (accountHigh ? highLimit : lowLimit).parse_issuer(account);\r\n        // The limit set by issuer.\r\n        var issuerLimit     = (accountHigh ? lowLimit : highLimit).parse_issuer(issuer);\r\n        var accountBalance  = (accountHigh ? balance.negate() : balance).parse_issuer(account);\r\n        var issuerBalance   = (accountHigh ? balance : balance.negate()).parse_issuer(issuer);\r\n\r\n        request.emit('ripple_state', {\r\n          'issuer_balance'  : issuerBalance,  // Balance with dst as issuer.\r\n          'account_balance' : accountBalance, // Balance with account as issuer.\r\n          'issuer_limit'    : issuerLimit,    // Limit set by issuer with src as issuer.\r\n          'account_limit'   : accountLimit    // Limit set by account with dst as issuer.\r\n        });\r\n      });\r\n};\r\n\r\nRemote.prototype.request_ripple_path_find = function (src_account, dst_account, dst_amount, source_currencies) {\r\n  var self    = this;\r\n  var request = new Request(this, 'ripple_path_find');\r\n\r\n  request.message.source_account      = UInt160.json_rewrite(src_account);\r\n  request.message.destination_account = UInt160.json_rewrite(dst_account);\r\n  request.message.destination_amount  = Amount.json_rewrite(dst_amount);\r\n  request.message.source_currencies   = source_currencies.map(function (ci) {\r\n      var ci_new  = {};\r\n\r\n      if ('issuer' in ci)\r\n        ci_new.issuer   = UInt160.json_rewrite(ci.issuer);\r\n\r\n      if ('currency' in ci)\r\n        ci_new.currency = Currency.json_rewrite(ci.currency);\r\n\r\n      return ci_new;\r\n    });\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.request_unl_list = function () {\r\n  return new Request(this, 'unl_list');\r\n};\r\n\r\nRemote.prototype.request_unl_add = function (addr, comment) {\r\n  var request = new Request(this, 'unl_add');\r\n\r\n  request.message.node    = addr;\r\n\r\n  if (comment !== undefined)\r\n    request.message.comment = note;\r\n\r\n  return request;\r\n};\r\n\r\n// --> node: <domain> | <public_key>\r\nRemote.prototype.request_unl_delete = function (node) {\r\n  var request = new Request(this, 'unl_delete');\r\n\r\n  request.message.node = node;\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.request_peers = function () {\r\n  return new Request(this, 'peers');\r\n};\r\n\r\nRemote.prototype.request_connect = function (ip, port) {\r\n  var request = new Request(this, 'connect');\r\n\r\n  request.message.ip = ip;\r\n\r\n  if (port)\r\n    request.message.port = port;\r\n\r\n  return request;\r\n};\r\n\r\nRemote.prototype.transaction = function () {\r\n  return new Transaction(this);\r\n};\r\n\r\n//\r\n// Transactions\r\n//\r\n//  Construction:\r\n//    remote.transaction()  // Build a transaction object.\r\n//     .offer_create(...)   // Set major parameters.\r\n//     .set_flags()         // Set optional parameters.\r\n//     .on()                // Register for events.\r\n//     .submit();           // Send to network.\r\n//\r\n//  Events:\r\n// 'success' : Transaction submitted without error.\r\n// 'error' : Error submitting transaction.\r\n// 'proposed' : Advisory proposed status transaction.\r\n// - A client should expect 0 to multiple results.\r\n// - Might not get back. The remote might just forward the transaction.\r\n// - A success could be reverted in final.\r\n// - local error: other remotes might like it.\r\n// - malformed error: local server thought it was malformed.\r\n// - The client should only trust this when talking to a trusted server.\r\n// 'final' : Final status of transaction.\r\n// - Only expect a final from dishonest servers after a tesSUCCESS or ter*.\r\n// 'lost' : Gave up looking for on ledger_closed.\r\n// 'pending' : Transaction was not found on ledger_closed.\r\n// 'state' : Follow the state of a transaction.\r\n//    'client_submitted'     - Sent to remote\r\n//     |- 'remoteError'      - Remote rejected transaction.\r\n//      \\- 'client_proposed' - Remote provisionally accepted transaction.\r\n//       |- 'client_missing' - Transaction has not appeared in ledger as expected.\r\n//       | |\\- 'client_lost' - No longer monitoring missing transaction.\r\n//       |/\r\n//       |- 'tesSUCCESS'     - Transaction in ledger as expected.\r\n//       |- 'ter...'         - Transaction failed.\r\n//       \\- 'tep...'         - Transaction partially succeeded.\r\n//\r\n// Notes:\r\n// - All transactions including those with local and malformed errors may be\r\n//   forwarded anyway.\r\n// - A malicous server can:\r\n//   - give any proposed result.\r\n//     - it may declare something correct as incorrect or something correct as incorrect.\r\n//     - it may not communicate with the rest of the network.\r\n//   - may or may not forward.\r\n//\r\n\r\nvar SUBMIT_MISSING  = 4;    // Report missing.\r\nvar SUBMIT_LOST     = 8;    // Give up tracking.\r\n\r\n// A class to implement transactions.\r\n// - Collects parameters\r\n// - Allow event listeners to be attached to determine the outcome.\r\nvar Transaction = function (remote) {\r\n  // YYY Make private as many variables as possible.\r\n  var self  = this;\r\n\r\n  this.callback     = undefined;\r\n  this.remote       = remote;\r\n  this._secret      = undefined;\r\n  this._build_path  = false;\r\n  this.tx_json      = {                 // Transaction data.\r\n    'Flags' : 0,                        // XXX Would be nice if server did not require this.\r\n  };\r\n  this.hash         = undefined;\r\n  this.submit_index = undefined;        // ledger_current_index was this when transaction was submited.\r\n  this.state        = undefined;        // Under construction.\r\n\r\n  this.on('success', function (message) {\r\n      if (message.engine_result) {\r\n        self.hash       = message.tx_json.hash;\r\n\r\n        self.set_state('client_proposed');\r\n\r\n        self.emit('proposed', {\r\n            'tx_json'         : message.tx_json,\r\n            'result'          : message.engine_result,\r\n            'result_code'     : message.engine_result_code,\r\n            'result_message'  : message.engine_result_message,\r\n            'rejected'        : self.isRejected(message.engine_result_code),      // If server is honest, don't expect a final if rejected.\r\n          });\r\n      }\r\n    });\r\n\r\n  this.on('error', function (message) {\r\n        // Might want to give more detailed information.\r\n        self.set_state('remoteError');\r\n    });\r\n};\r\n\r\nTransaction.prototype  = new EventEmitter;\r\n\r\nTransaction.prototype.consts = {\r\n  'telLOCAL_ERROR'  : -399,\r\n  'temMALFORMED'    : -299,\r\n  'tefFAILURE'      : -199,\r\n  'terRETRY'        : -99,\r\n  'tesSUCCESS'      : 0,\r\n  'tepPARTIAL'      : 100,\r\n};\r\n\r\nTransaction.prototype.isTelLocal = function (ter) {\r\n  return ter >= this.consts.telLOCAL_ERROR && ter < this.consts.temMALFORMED;\r\n};\r\n\r\nTransaction.prototype.isTemMalformed = function (ter) {\r\n  return ter >= this.consts.temMALFORMED && ter < this.consts.tefFAILURE;\r\n};\r\n\r\nTransaction.prototype.isTefFailure = function (ter) {\r\n  return ter >= this.consts.tefFAILURE && ter < this.consts.terRETRY;\r\n};\r\n\r\nTransaction.prototype.isTerRetry = function (ter) {\r\n  return ter >= this.consts.terRETRY && ter < this.consts.tesSUCCESS;\r\n};\r\n\r\nTransaction.prototype.isTepSuccess = function (ter) {\r\n  return ter >= this.consts.tesSUCCESS;\r\n};\r\n\r\nTransaction.prototype.isTepPartial = function (ter) {\r\n  return ter >= this.consts.tepPATH_PARTIAL;\r\n};\r\n\r\nTransaction.prototype.isRejected = function (ter) {\r\n  return this.isTelLocal(ter) || this.isTemMalformed(ter) || this.isTefFailure(ter);\r\n};\r\n\r\nTransaction.prototype.set_state = function (state) {\r\n  if (this.state !== state) {\r\n    this.state  = state;\r\n    this.emit('state', state);\r\n  }\r\n};\r\n\r\n// Submit a transaction to the network.\r\n// XXX Don't allow a submit without knowing ledger_index.\r\n// XXX Have a network canSubmit(), post events for following.\r\n// XXX Also give broader status for tracking through network disconnects.\r\n// callback = function (status, info) {\r\n//   // status is final status.  Only works under a ledger_accepting conditions.\r\n//   switch status:\r\n//    case 'tesSUCCESS': all is well.\r\n//    case 'tejServerUntrusted': sending secret to untrusted server.\r\n//    case 'tejInvalidAccount': locally detected error.\r\n//    case 'tejLost': locally gave up looking\r\n//    default: some other TER\r\n// }\r\nTransaction.prototype.submit = function (callback) {\r\n  var self    = this;\r\n  var tx_json = this.tx_json;\r\n\r\n  this.callback = callback;\r\n\r\n  if ('string' !== typeof tx_json.Account)\r\n  {\r\n    (this.callback || this.emit)('error', {\r\n        'error' : 'tejInvalidAccount',\r\n        'error_message' : 'Bad account.'\r\n      });\r\n    return;\r\n  }\r\n\r\n  // YYY Might check paths for invalid accounts.\r\n\r\n  if (this.remote.local_fee && undefined === tx_json.Fee) {\r\n    if ('Payment' === tx_json.TransactionType\r\n      && tx_json.Flags & Remote.flags.Payment.CreateAccount) {\r\n\r\n      tx_json.Fee    = Remote.fees.account_create.to_json();\r\n    }\r\n    else {\r\n      tx_json.Fee    = Remote.fees['default'].to_json();\r\n    }\r\n  }\r\n\r\n  if (this.callback || this.listeners('final').length || this.listeners('lost').length || this.listeners('pending').length) {\r\n    // There are listeners for callback, 'final', 'lost', or 'pending' arrange to emit them.\r\n\r\n    this.submit_index = this.remote._ledger_current_index;\r\n\r\n    // When a ledger closes, look for the result.\r\n    var on_ledger_closed = function (message) {\r\n        var ledger_hash   = message.ledger_hash;\r\n        var ledger_index  = message.ledger_index;\r\n        var stop          = false;\r\n\r\n// XXX make sure self.hash is available.\r\n        self.remote.request_transaction_entry(self.hash)\r\n          .ledger_hash(ledger_hash)\r\n          .on('success', function (message) {\r\n              self.set_state(message.metadata.TransactionResult);\r\n              self.emit('final', message);\r\n\r\n              if (self.callback)\r\n                self.callback(message.metadata.TransactionResult, message);\r\n\r\n              stop  = true;\r\n            })\r\n          .on('error', function (message) {\r\n              if ('remoteError' === message.error\r\n                && 'transactionNotFound' === message.remote.error) {\r\n                if (self.submit_index + SUBMIT_LOST < ledger_index) {\r\n                  self.set_state('client_lost');        // Gave up.\r\n                  self.emit('lost');\r\n\r\n                  if (self.callback)\r\n                    self.callback('tejLost', message);\r\n\r\n                  stop  = true;\r\n                }\r\n                else if (self.submit_index + SUBMIT_MISSING < ledger_index) {\r\n                  self.set_state('client_missing');    // We don't know what happened to transaction, still might find.\r\n                  self.emit('pending');\r\n                }\r\n                else {\r\n                  self.emit('pending');\r\n                }\r\n              }\r\n              // XXX Could log other unexpectedness.\r\n            })\r\n          .request();\r\n\r\n        if (stop) {\r\n          self.remote.removeListener('ledger_closed', on_ledger_closed);\r\n          self.emit('final', message);\r\n        }\r\n      };\r\n\r\n    this.remote.on('ledger_closed', on_ledger_closed);\r\n\r\n    if (this.callback) {\r\n      this.on('error', function (message) {\r\n          self.callback(message.error, message);\r\n        });\r\n    }\r\n  }\r\n\r\n  this.set_state('client_submitted');\r\n\r\n  this.remote.submit(this);\r\n\r\n  return this;\r\n}\r\n\r\n//\r\n// Set options for Transactions\r\n//\r\n\r\n// --> build: true, to have server blindly construct a path.\r\n//\r\n// \"blindly\" because the sender has no idea of the actual cost except that is must be less than send max.\r\nTransaction.prototype.build_path = function (build) {\r\n  this._build_path = build;\r\n\r\n  return this;\r\n}\r\n\r\nTransaction._path_rewrite = function (path) {\r\n  var path_new  = [];\r\n\r\n  for (var index in path) {\r\n    var node      = path[index];\r\n    var node_new  = {};\r\n\r\n    if ('account' in node)\r\n      node_new.account  = UInt160.json_rewrite(node.account);\r\n\r\n    if ('issuer' in node)\r\n      node_new.issuer   = UInt160.json_rewrite(node.issuer);\r\n\r\n    if ('currency' in node)\r\n      node_new.currency = Currency.json_rewrite(node.currency);\r\n\r\n    path_new.push(node_new);\r\n  }\r\n\r\n  return path_new;\r\n}\r\n\r\nTransaction.prototype.path_add = function (path) {\r\n  this.tx_json.Paths  = this.tx_json.Paths || []\r\n  this.tx_json.Paths.push(Transaction._path_rewrite(path));\r\n\r\n  return this;\r\n}\r\n\r\n// --> paths: undefined or array of path\r\n// A path is an array of objects containing some combination of: account, currency, issuer\r\nTransaction.prototype.paths = function (paths) {\r\n  for (var index in paths) {\r\n    this.path_add(paths[index]);\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\n// If the secret is in the config object, it does not need to be provided.\r\nTransaction.prototype.secret = function (secret) {\r\n  this._secret = secret;\r\n}\r\n\r\nTransaction.prototype.send_max = function (send_max) {\r\n  if (send_max)\r\n      this.tx_json.SendMax = Amount.json_rewrite(send_max);\r\n\r\n  return this;\r\n}\r\n\r\n// --> rate: In billionths.\r\nTransaction.prototype.transfer_rate = function (rate) {\r\n  this.tx_json.TransferRate = Number(rate);\r\n\r\n  if (this.tx_json.TransferRate < 1e9)\r\n    throw 'invalidTransferRate';\r\n\r\n  return this;\r\n}\r\n\r\n// Add flags to a transaction.\r\n// --> flags: undefined, _flag_, or [ _flags_ ]\r\nTransaction.prototype.set_flags = function (flags) {\r\n  if (flags) {\r\n      var   transaction_flags = Remote.flags[this.tx_json.TransactionType];\r\n\r\n      if (undefined == this.tx_json.Flags)      // We plan to not define this field on new Transaction.\r\n        this.tx_json.Flags        = 0;\r\n\r\n      var flag_set  = 'object' === typeof flags ? flags : [ flags ];\r\n\r\n      for (index in flag_set) {\r\n        var flag  = flag_set[index];\r\n\r\n        if (flag in transaction_flags)\r\n        {\r\n          this.tx_json.Flags      += transaction_flags[flag];\r\n        }\r\n        else {\r\n          // XXX Immediately report an error or mark it.\r\n        }\r\n      }\r\n\r\n      if (this.remote.local_fee && (this.tx_json.Flags & Remote.flags.Payment.CreateAccount))\r\n        this.tx_json.Fee        = Remote.fees.account_create.to_json();\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\n//\r\n// Transactions\r\n//\r\n\r\nTransaction.prototype._account_secret = function (account) {\r\n  // Fill in secret from remote, if available.\r\n  return this.remote.secrets[account];\r\n};\r\n\r\n// Options:\r\n//  .domain()           NYI\r\n//  .message_key()      NYI\r\n//  .transfer_rate()\r\n//  .wallet_locator()   NYI\r\nTransaction.prototype.account_set = function (src) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'AccountSet';\r\n  this.tx_json.Account          = UInt160.json_rewrite(src);\r\n\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.claim = function (src, generator, public_key, signature) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'Claim';\r\n  this.tx_json.Generator        = generator;\r\n  this.tx_json.PublicKey        = public_key;\r\n  this.tx_json.Signature        = signature;\r\n\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.offer_cancel = function (src, sequence) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'OfferCancel';\r\n  this.tx_json.Account          = UInt160.json_rewrite(src);\r\n  this.tx_json.OfferSequence    = Number(sequence);\r\n\r\n  return this;\r\n};\r\n\r\n// --> expiration : Date or Number\r\nTransaction.prototype.offer_create = function (src, taker_pays, taker_gets, expiration) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'OfferCreate';\r\n  this.tx_json.Account          = UInt160.json_rewrite(src);\r\n  this.tx_json.TakerPays        = Amount.json_rewrite(taker_pays);\r\n  this.tx_json.TakerGets        = Amount.json_rewrite(taker_gets);\r\n\r\n  if (this.remote.local_fee) {\r\n    this.tx_json.Fee            = Remote.fees.offer.to_json();\r\n  }\r\n\r\n  if (expiration)\r\n    this.tx_json.Expiration  = Date === expiration.constructor\r\n                                    ? expiration.getTime()\r\n                                    : Number(expiration);\r\n\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.password_fund = function (src, dst) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'PasswordFund';\r\n  this.tx_json.Destination      = UInt160.json_rewrite(dst);\r\n\r\n  return this;\r\n}\r\n\r\nTransaction.prototype.password_set = function (src, authorized_key, generator, public_key, signature) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'PasswordSet';\r\n  this.tx_json.RegularKey       = authorized_key;\r\n  this.tx_json.Generator        = generator;\r\n  this.tx_json.PublicKey        = public_key;\r\n  this.tx_json.Signature        = signature;\r\n\r\n  return this;\r\n}\r\n\r\n// Construct a 'payment' transaction.\r\n//\r\n// When a transaction is submitted:\r\n// - If the connection is reliable and the server is not merely forwarding and is not malicious,\r\n// --> src : UInt160 or String\r\n// --> dst : UInt160 or String\r\n// --> deliver_amount : Amount or String.\r\n//\r\n// Options:\r\n//  .paths()\r\n//  .build_path()\r\n//  .path_add()\r\n//  .secret()\r\n//  .send_max()\r\n//  .set_flags()\r\nTransaction.prototype.payment = function (src, dst, deliver_amount) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'Payment';\r\n  this.tx_json.Account          = UInt160.json_rewrite(src);\r\n  this.tx_json.Amount           = Amount.json_rewrite(deliver_amount);\r\n  this.tx_json.Destination      = UInt160.json_rewrite(dst);\r\n\r\n  return this;\r\n}\r\n\r\nTransaction.prototype.ripple_line_set = function (src, limit, quality_in, quality_out) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'TrustSet';\r\n  this.tx_json.Account          = UInt160.json_rewrite(src);\r\n\r\n  // Allow limit of 0 through.\r\n  if (undefined !== limit)\r\n    this.tx_json.LimitAmount  = Amount.json_rewrite(limit);\r\n\r\n  if (quality_in)\r\n    this.tx_json.QualityIn    = quality_in;\r\n\r\n  if (quality_out)\r\n    this.tx_json.QualityOut   = quality_out;\r\n\r\n  // XXX Throw an error if nothing is set.\r\n\r\n  return this;\r\n};\r\n\r\nTransaction.prototype.wallet_add = function (src, amount, authorized_key, public_key, signature) {\r\n  this._secret                  = this._account_secret(src);\r\n  this.tx_json.TransactionType  = 'WalletAdd';\r\n  this.tx_json.Amount           = Amount.json_rewrite(amount);\r\n  this.tx_json.RegularKey       = authorized_key;\r\n  this.tx_json.PublicKey        = public_key;\r\n  this.tx_json.Signature        = signature;\r\n\r\n  return this;\r\n};\r\n\r\nexports.config          = {};\r\nexports.Remote          = Remote;\r\n\r\n// vim:sw=2:sts=2:ts=8:et\r\n\n\n// WEBPACK FOOTER //\n// module.id = 1\n// module.realId = 7\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/remote.js");
/******/ /* WEBPACK FREE VAR INJECTION */ }(require(/* __webpack_console */1)))

/******/},
/******/
/******/8: function(module, exports, require) {

/******/ /* WEBPACK FREE VAR INJECTION */ (function(console) {
eval("exports = module.exports = require(4);\r\n\r\n// We override this function for browsers, because they print objects nicer\r\n// natively than JSON.stringify can.\r\nexports.logObject = function (msg, obj) {\r\n  console.log(msg, \"\", obj);\r\n};\r\n\n\n// WEBPACK FOOTER //\n// module.id = 5\n// module.realId = 8\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/src/js/utils.web.js");
/******/ /* WEBPACK FREE VAR INJECTION */ }(require(/* __webpack_console */1)))

/******/},
/******/
/******/9: function(module, exports, require) {

eval("module.exports = WebSocket;\r\n\n\n// WEBPACK FOOTER //\n// module.id = 3\n// module.realId = 9\n// module.chunks = main\n//@ sourceURL=webpack-module:///D:/code/NewCoin/web_modules/ws.js");

/******/}
/******/})